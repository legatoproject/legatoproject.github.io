<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" SYSTEM "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Event Loop API  - Legato Docs</title>
<meta content="legatoâ„¢ is an open source Linux-based embedded platform designed to simplify connected IoT application development" name="description" />
<meta content="#keywords" name="keywords" />
<meta content="noindex, nofollow" name="robots" />
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
<link href="/resources/images/legato.ico" rel="shortcut icon" />
<link href="/resources/images/legato.ico" rel="icon" type="image/x-icon" />
<link href="/resources/images/legato.ico" rel="shortcut icon" type="image/x-icon" />
<link href="#" rel="apple-touch-icon" />
<link href="#" rel="apple-touch-icon" sizes="72x72" />
<link href="#" rel="apple-touch-icon" sizes="114x114" />
<link href="/resources/css/style.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/resources/css/font-awesome.css" rel="stylesheet" type="text/css" />
<!--[if IE]>
        <script src="/resources/js/html5shiv.js"></script>
        <script src="/resources/js/respond.js"></script>
        <![endif]-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
<script src="/resources/js/main.js"></script>
<link href="/resources/css/jqtree.css" rel="stylesheet" type="text/css" />
<script src="/resources/js/tree.jquery.js" type="text/javascript"></script>
<script src="/resources/js/jquery.cookie.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<script>
        setupTree("/resources/tocs/Build Apps Documentation.json");
        </script>
</head>
<body>
<div class="wrapper">
<div class="fa fa-bars documentation" id="menu-trigger"></div>
<div id="top">
<header>
<nav>
<a class="navlink" href="/index.html">Introduction</a><a class="navlink" href="/docs/getstarted_main.html">Build Apps</a><a class="subnavlink" href="/docs/getstarted_main.html">Get started</a><a class="subnavlink" href="/docs/build_apps_documentation.html">Documentation</a><a class="subnavlink" href="/docs/files.html">Reference</a><a class="navlink" href="/docs/platform_constraints.html">Build Platform</a><a class="subnavlink" href="/docs/platform_constraints.html">Platform Constraints</a><a class="subnavlink" href="/docs/yocto_main.html">Yocto Info</a><a class="navlink" href="/docs/about_main.html">About</a>
</nav>
</header>
</div>
<div class="orange" id="menudocumentation">
<header>
<h1><a class="navlink" href="/" title="back to Legato homepage">Legato</a></h1>
<h2>/ Build Apps</h2>
<nav class="ui-front" id="searchresult">
<i class="fa fa-search"></i>
<input id="autocomplete" onkeyup="getdata('Build Apps')" placeholder="Search..." /> <!-- <input id="category" type="checkbox" onclick="checkbox()"> <label for="category">API Search</label> -->
</nav>
</header>
</div>
<div class="orange" id="topMenu">
<nav>
<a href="getstarted_main.html">Get Started</a><a class="link-selected" href="build_apps_documentation.html">Documentation</a><a href="files.html">Reference</a>
</nav>
</div>
<div id="left">
<div id="tree1"></div>
</div>
<div class="content">
<div class="header">
<div class="headertitle">
<h1 class="title">Event Loop API </h1> </div>
</div><div class="contents">
<div class="textblock"><p><a class="el" href="le__event_loop_8h.html">API Reference</a></p>
<hr />
<p>The Event Loop API supports the event-driven programming model, which is favoured in Legato (but not forced). Each thread that uses this system has a central <b>event loop</b> which calls <b>event handler</b> functions in response to <b>event reports</b>.</p>
<p>Software components register their event handler functions with the event system (either directly through the Event Loop API or indirectly through other APIs that use the Event Loop API) so the central event loop knows the functions to call in response to defined events.</p>
<p>Every event loop has an <b>event queue</b>, which is a queue of events waiting to be handled by that event loop.</p>
<dl class="section note"><dt>Note</dt><dd>When the process dies, all events, event loops, queues, reports, and handlers will be automatically cleared.</dd></dl>
<p>The following different usage patterns are supported by the Event Loop API:</p>
<p><a class="el" href="c_event_loop.html#c_event_deferredFunctionCalls">Deferred Function Calls</a> <br />
<a class="el" href="c_event_loop.html#c_event_dispatchingToOtherThreads">Dispatching Function Execution to Other Threads</a> <br />
<a class="el" href="c_event_loop.html#c_event_publishSubscribe">Publish-Subscribe Events</a> <br />
<a class="el" href="c_event_loop.html#c_event_layeredPublishSubscribe">Layered Publish-Subscribe Handlers</a> <br />
</p>
<p>Other Legato C Runtime Library APIs using the event loop include:</p>
<p><a class="el" href="c_fd_monitor.html">File Descriptor Monitor API</a> <br />
<a class="el" href="c_timer.html">Timer API</a> <br />
<a class="el" href="c_args.html">Command Line Arguments API</a> <br />
<a class="el" href="c_signals.html">Signals API</a> <br />
<a class="el" href="c_messaging.html">Low-Level Messaging API</a> <br />
</p>
<h1><a class="anchor" id="c_event_deferredFunctionCalls"></a>
Deferred Function Calls</h1>
<p>A basic Event Queue usage is to queue a function for the Event Loop to call later (when that function gets to the head of the Event Queue) by calling l<code>e_event_QueueFunction()</code>.</p>
<p>This code sample has a component initialization function queueing another function to be call later, by the process's main thread when the Event Loop is running. Two parameters are needed by the deferred function. The third is just filled with NULL and ignored by the deferred function.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyDeferredFunction</div><div class="line">(</div><div class="line"> <span class="keywordtype">void</span>* param1Ptr,</div><div class="line"> <span class="keywordtype">void</span>* param2Ptr</div><div class="line">)</div><div class="line">{</div><div class="line"> <span class="comment">// Type cast the parameters to what they really are and do whatever it is that</span></div><div class="line"> <span class="comment">// I need to do with them.</span></div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">COMPONENT_INIT</div><div class="line">{</div><div class="line"> <a class="code" href="le__event_loop_8h.html#a6dcc88f96060c5bc107a81a978132f38">le_event_QueueFunction</a>(MyDeferredFunction, firstParamPtr, secondParamPtr);</div><div class="line">}</div></div><!-- fragment --><p>Deferred function calls are useful when implementing APIs with asynchronous result call-backs. If an error is detected before the API function returns, it can't just call the call-back directly, because it could cause re-entrancy problems in the client code or cause recursive loops. Instead of forcing the API function to return an error code in special cases (which will increase the client's code complexity and may leak API implementation details to the client), the API function can defers executing the call-back until later by queuing an error handling function onto the Event Queue.</p>
<h1><a class="anchor" id="c_event_dispatchingToOtherThreads"></a>
Dispatching Function Execution to Other Threads</h1>
<p>In multi-threaded programs, sometimes the implementor needs to ask another thread to run a function because:</p><ul>
<li>The function to be executed takes a long time, but doesn't have to be done at a high priority.</li>
<li>A call needs to be made into a non-thread-safe API function.</li>
<li>A blocking function needs to be called, but the current thread can't afford to block.</li>
</ul>
<p>To assist with this, the Event Loop API provides <code><a class="el" href="le__event_loop_8h.html#a228da2d1f53ffa74517f108b0dcfa4d9">le_event_QueueFunctionToThread()</a></code>. It works the same as <a class="el" href="le__event_loop_8h.html#a6dcc88f96060c5bc107a81a978132f38">le_event_QueueFunction()</a>, except that it queues the function onto a specific thread's Event Queue.</p>
<p>If the other thread isn't running the Event Loop, then the queued function will never be executed.</p>
<p>This code sample shows two arguments started by the process's main thread, and executed in the background by a low-priority thread. The result is reported back to the client through a completion callback running in the same thread that requested that the computation be performed.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> le_mem_PoolRef_t ComputeRequestPool;</div><div class="line"><span class="keyword">static</span> <a class="code" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> LowPriorityThreadRef;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">{</div><div class="line"> <span class="keywordtype">size_t</span>           arg1;                                   <span class="comment">// First argument</span></div><div class="line"> <span class="keywordtype">size_t</span>           arg2;                                   <span class="comment">// Second argument</span></div><div class="line">    ssize_t          result;                                 <span class="comment">// The result</span></div><div class="line">    void           (*completionCallback)(ssize_t result);    <span class="comment">// The client's completion callback</span></div><div class="line"> <a class="code" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>  requestingThreadRef;                    <span class="comment">// The client's thread.</span></div><div class="line">}</div><div class="line">ComputeRequest_t;</div><div class="line"></div><div class="line"><span class="comment">// Main function of low-priority background thread.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span>* LowPriorityThreadMain</div><div class="line">(</div><div class="line"> <span class="keywordtype">void</span>* contextPtr <span class="comment">// not used.</span></div><div class="line">)</div><div class="line">{</div><div class="line"> <a class="code" href="le__event_loop_8h.html#ae313b457994371c658be9fe0494a01ff">le_event_RunLoop</a>();</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line">    ComputeRequestPool = <a class="code" href="le__mem_8h.html#ab91efaa2978c9c1c7b2427d25b33241c">le_mem_CreatePool</a>(<span class="stringliteral">"Compute Request"</span>, <span class="keyword">sizeof</span>(ComputeRequest_t));</div><div class="line"></div><div class="line">    LowPriorityThreadRef = <a class="code" href="le__thread_8h.html#a87e02a46f92e9e3e11ed28a2b265872f">le_thread_Create</a>(<span class="stringliteral">"Background Computation Thread"</span>,</div><div class="line">                                            LowPriorityThreadMain,</div><div class="line">                                            NULL);</div><div class="line"> <a class="code" href="le__thread_8h.html#a95257a2f60cacdadc787647453b77356">le_thread_SetPriority</a>(LowPriorityThreadRef, <a class="code" href="le__thread_8h.html#a653b0f17cd4d4567c86a25e23d004f07a8237422b4c3d3df0ffcdbc9981c45d98">LE_THREAD_PRIORITY_IDLE</a>);</div><div class="line"> <a class="code" href="le__thread_8h.html#a38df3877ee5ab9fac17b2fc0be46c27e">le_thread_Start</a>(LowPriorityThreadRef);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// This function gets run by a low-priority, background thread.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ComputeResult</div><div class="line">(</div><div class="line"> <span class="keywordtype">void</span>* param1Ptr, <span class="comment">// request object pointer</span></div><div class="line"> <span class="keywordtype">void</span>* param2Ptr  <span class="comment">// not used</span></div><div class="line">)</div><div class="line">{</div><div class="line">    ComputeRequest_t* requestPtr = param1Ptr;</div><div class="line"></div><div class="line">    requestPtr->result = DoSomeReallySlowComputation(requestPtr->arg1, requestPtr->arg2);</div><div class="line"></div><div class="line"> <a class="code" href="le__event_loop_8h.html#a228da2d1f53ffa74517f108b0dcfa4d9">le_event_QueueFunctionToThread</a>(requestPtr->requestingThreadRef,</div><div class="line">                                   ProcessResult,</div><div class="line">                                   requestPtr,</div><div class="line">                                   NULL);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// This function gets called by a component running in the main thread.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ComputeResultInBackground</div><div class="line">(</div><div class="line"> <span class="keywordtype">size_t</span> arg1,</div><div class="line"> <span class="keywordtype">size_t</span> arg2,</div><div class="line"> <span class="keywordtype">void</span> (*completionCallback)(ssize_t result)</div><div class="line">)</div><div class="line">{</div><div class="line">    ComputeRequest_t* requestPtr = <a class="code" href="le__mem_8h.html#af7c289c73d4182835a26a9099f3db359">le_mem_ForceAlloc</a>(ComputeRequestPool);</div><div class="line">    requestPtr->arg1 = arg1;</div><div class="line">    requestPtr->arg2 = arg2;</div><div class="line">    requestPtr->requestingThreadRef = <a class="code" href="le__thread_8h.html#a90a9d67db26f816fd1e1032d74a24fcd">le_thread_GetCurrent</a>();</div><div class="line">    requestPtr->completionCallback = completionCallback;</div><div class="line"> <a class="code" href="le__event_loop_8h.html#a228da2d1f53ffa74517f108b0dcfa4d9">le_event_QueueFunctionToThread</a>(LowPriorityThreadRef,</div><div class="line">                                   ComputeResult,</div><div class="line">                                   requestPtr,</div><div class="line">                                   NULL);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// This function gets run by the main thread.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ProcessResult</div><div class="line">(</div><div class="line"> <span class="keywordtype">void</span>* param1Ptr, <span class="comment">// request object pointer</span></div><div class="line"> <span class="keywordtype">void</span>* param2Ptr  <span class="comment">// not used</span></div><div class="line">)</div><div class="line">{</div><div class="line">    ComputeRequest_t* requestPtr = param1Ptr;</div><div class="line">    completionCallback(requestPtr->result);</div><div class="line"> <a class="code" href="le__mem_8h.html#a6d8e3fe430bcb81efe97b57ce30ef2de">le_mem_Release</a>(requestPtr);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="c_event_publishSubscribe"></a>
Publish-Subscribe Events</h1>
<p>In the publish-subscribe pattern, someone publishes information and if anyone cares about that information, they subscribe to receive it. The publisher doesn't have to know whether anything is listening, or how many subscribers might be listening. Likewise, the subscribers don't have to know whether anything is publishing or how many publishers there might be. This decouples publishers and subscribers.</p>
<p>Subscribers <b>add</b> handlers for events and wait for those handlers to be executed.</p>
<p>Publishers <b>report</b> events.</p>
<p>When an event report reaches the front of an Event Queue, the Event Loop will pop it from the queue and call any handlers that have been registered for that event.</p>
<p>Events are identified using an <b> Event ID </b> created by calling <code><a class="el" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId()</a></code> before registering an handler for that event or report. Any thread within the process with an Event ID can register a handler or report events.</p>
<dl class="section note"><dt>Note</dt><dd>These Event IDs are only valid within the process where they were created. The Event Loop API can't be used for inter-process communication (IPC).</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> eventId = <a class="code" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId</a>(<span class="stringliteral">"MyEvent"</span>, <span class="keyword">sizeof</span>(MyEventReport_t));</div></div><!-- fragment --><p>Event reports can carry a payload. The size and format of the payload depends on the type of event. For example, reports of temperature changes may need to carry the new temperature. To support this, <code><a class="el" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId()</a></code> takes the payload size as a parameter.</p>
<p>To report an event, the publisher builds their report payload in their own buffer and passes a pointer to that buffer (and its size) to <code><a class="el" href="le__event_loop_8h.html#ae3ffe6990b70fb572b4eef06739b4f54">le_event_Report()</a></code>:</p>
<div class="fragment"><div class="line">MyEventReport_t report;</div><div class="line">...     <span class="comment">// Fill in the event report.</span></div><div class="line"><a class="code" href="le__event_loop_8h.html#ae3ffe6990b70fb572b4eef06739b4f54">le_event_Report</a>(EventId, &report, <span class="keyword">sizeof</span>(report));</div></div><!-- fragment --><p>This results in the report getting queued to the Event Queues of all threads with handlers registered for that event ID.</p>
<p>To register a handler, the subscriber calls <code><a class="el" href="le__event_loop_8h.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler()</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>It's okay to have a payload size of zero, in which case NULL can be passed into <a class="el" href="le__event_loop_8h.html#ae3ffe6990b70fb572b4eef06739b4f54">le_event_Report()</a>.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a> handlerRef = <a class="code" href="le__event_loop_8h.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler</a>(<span class="stringliteral">"MyHandler"</span>, eventId, MyHandlerFunc);</div></div><!-- fragment --><p>When an event report reaches the front of a thread's Event Queue, that thread's Event Loop reads the report and then:</p><ul>
<li>Calls the handler functions registered by that thread.</li>
<li>Points to the report payload passed to the handler as a parameter.</li>
<li>Reports the payload was deleted on return, so the handler function must copy any contents to keep.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyHandlerFunc</div><div class="line">(</div><div class="line"> <span class="keywordtype">void</span>* reportPayloadPtr</div><div class="line">)</div><div class="line">{</div><div class="line">    MyEventReport_t* reportPtr = reportPayloadPtr;</div><div class="line"> <span class="comment">// Process the report.</span></div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p>Another opaque pointer, called the <b> context pointer </b> can be set for the handler using <code><a class="el" href="le__event_loop_8h.html#ae0c4307a9715794c720e525032aa0bfd">le_event_SetContextPtr()</a></code>. When the handler function is called, it can call <a class="el" href="le__event_loop_8h.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr()</a> to fetch the context pointer.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyHandlerFunc</div><div class="line">(</div><div class="line"> <span class="keywordtype">void</span>* reportPayloadPtr</div><div class="line">)</div><div class="line">{</div><div class="line">    MyEventReport_t* reportPtr = reportPayloadPtr;</div><div class="line">    MyContext_t* contextPtr = <a class="code" href="le__event_loop_8h.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr</a>();</div><div class="line"></div><div class="line"> <span class="comment">// Process the report.</span></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line">    MyEventId = <a class="code" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId</a>(<span class="stringliteral">"MyEvent"</span>, <span class="keyword">sizeof</span>(MyEventReport_t));</div><div class="line"></div><div class="line">    MyHandlerRef = <a class="code" href="le__event_loop_8h.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler</a>(<span class="stringliteral">"MyHandler"</span>, MyEventId, MyHandlerFunc);</div><div class="line"> <a class="code" href="le__event_loop_8h.html#ae0c4307a9715794c720e525032aa0bfd">le_event_SetContextPtr</a>(MyHandlerRef, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));</div><div class="line">}</div></div><!-- fragment --><p>Finally, <a class="el" href="le__event_loop_8h.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler()</a> can be used to remove an event handler registration, if necessary.</p>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler</a>(MyHandlerRef);</div></div><!-- fragment --><p>If a handler is removed after the report for that event has been added to the event queue, but before the report reaches the head of the queue, then the handler will not be called.</p>
<dl class="section note"><dt>Note</dt><dd>To prevent race conditions, it's not permitted for one thread to remove another thread's handlers.</dd></dl>
<h1><a class="anchor" id="c_event_layeredPublishSubscribe"></a>
Layered Publish-Subscribe Handlers</h1>
<p>If you need to implement an API that allows clients to register "handler" functions to be called-back after a specific event occurs, the Event Loop API provides some special help.</p>
<p>You can have the Event Loop call your handler function (the first-layer handler), to unpack specified items from the Event Report and call the client's handler function (the second-layer handler).</p>
<p>For example, you could create a "Temperature Sensor API" that allows its clients to register handler functions to be called to handle changes in the temperature, like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Temperature change handler functions must look like this.</span></div><div class="line"><span class="keyword">typedef</span> void (*tempSensor_ChangeHandlerFunc_t)(int32_t newTemperature, <span class="keywordtype">void</span>* contextPtr);</div><div class="line"></div><div class="line"><span class="comment">// Opaque type used to refer to a registered temperature change handler.</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>tempSensor_ChangeHandler* tempSensor_ChangeHandlerRef_t;</div><div class="line"></div><div class="line"><span class="comment">// Register a handler function to be called when the temperature changes.</span></div><div class="line">tempSensor_ChangeHandlerRef_t tempSensor_AddChangeHandler</div><div class="line">(</div><div class="line">    tempSensor_ChangeHandlerFunc_t  handlerFunc,  <span class="comment">// The handler function.</span></div><div class="line"> <span class="keywordtype">void</span>*                           contextPtr    <span class="comment">// Opaque pointer to pass to handler function.</span></div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// De-register a handler function that was previously registered using</span></div><div class="line"><span class="comment">// tempSensor_AddChangeHandler().</span></div><div class="line"><span class="keywordtype">void</span> tempSensor_RemoveChangeHandler</div><div class="line">(</div><div class="line">    tempSensor_ChangeHandlerRef_t  handlerRef</div><div class="line">);</div></div><!-- fragment --><p>The implementation could look like this:</p>
<div class="fragment"><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line">    TempChangeEventId = <a class="code" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId</a>(<span class="stringliteral">"TempChange"</span>, <span class="keyword">sizeof</span>(int32_t));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> TempChangeHandler</div><div class="line">(</div><div class="line"> <span class="keywordtype">void</span>* reportPtr,</div><div class="line"> <span class="keywordtype">void</span>* secondLayerHandlerFunc</div><div class="line">)</div><div class="line">{</div><div class="line">    int32_t* temperaturePtr = reportPtr;</div><div class="line">    tempSensor_ChangeHandlerRef_t clientHandlerFunc = secondLayerHandlerFunc;</div><div class="line"></div><div class="line">    clientHandlerFunc(*temperaturePtr, <a class="code" href="le__event_loop_8h.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr</a>());</div><div class="line">}</div><div class="line"></div><div class="line">tempSensor_ChangeHandlerRef_t tempSensor_AddChangeHandler</div><div class="line">(</div><div class="line">    tempSensor_ChangeHandlerFunc_t  handlerFunc,</div><div class="line"> <span class="keywordtype">void</span>*                           contextPtr</div><div class="line">)</div><div class="line">{</div><div class="line"> <a class="code" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a> handlerRef;</div><div class="line"></div><div class="line">    handlerRef = <a class="code" href="le__event_loop_8h.html#a8b906d38935f64953482f42c745e1c18">le_event_AddLayeredHandler</a>(<span class="stringliteral">"TempChange"</span>,</div><div class="line">                                            TempChangeEventId,</div><div class="line">                                            TempChangeHandler,</div><div class="line">                                            handlerFunc);</div><div class="line"> <a class="code" href="le__event_loop_8h.html#ae0c4307a9715794c720e525032aa0bfd">le_event_SetContextPtr</a>(handlerRef, contextPtr);</div><div class="line"></div><div class="line"> <span class="keywordflow">return</span> (tempSensor_ChangeHandlerRef_t)handlerRef;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> tempSensor_RemoveChangeHandler</div><div class="line">(</div><div class="line">    tempSensor_ChangeHandlerRef_t    handlerRef</div><div class="line">)</div><div class="line">{</div><div class="line"> <a class="code" href="le__event_loop_8h.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler</a>((<a class="code" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a>)handlerRef);</div><div class="line">}</div></div><!-- fragment --><p>This approach gives strong type checking of both handler references and handler function pointers in code that uses this Temperature Sensor API.</p>
<h1><a class="anchor" id="c_event_reportingRefCountedObjects"></a>
Event Reports Containing Reference-Counted Objects</h1>
<p>Sometimes you need to report an event where the report payload is pointing to a reference-counted object allocated from a memory pool (see <a class="el" href="c_memory.html">Dynamic Memory Allocation API</a>). Memory leaks and/or crashes can result if its is sent through the Event Loop API without telling the Event Loop API it's pointing to a reference counted object. If there are no subscribers, the Event Loop API iscards the reference without releasing it, and the object is never be deleted. If multiple handlers are registered, the reference could be released by the handlers too many times. Also, there are other, subtle issues that are nearly impossible to solve if threads terminate while reports containing pointers to reference-counted objects are on their Event Queues.</p>
<p>To help with this, the functions <code><a class="el" href="le__event_loop_8h.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting()</a></code> and <code><a class="el" href="le__event_loop_8h.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting()</a></code> have been provided. These allow a pointer to a reference-counted memory pool object to be sent as the payload of an Event Report.</p>
<p><code><a class="el" href="le__event_loop_8h.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting()</a></code> passes ownership of one reference to the Event Loop API, and when the handler is called, it receives ownership for one reference. It then becomes the handler's responsibility to release its reference (using <a class="el" href="le__mem_8h.html#a6d8e3fe430bcb81efe97b57ce30ef2de">le_mem_Release()</a>) when it's done.</p>
<p><code><a class="el" href="le__event_loop_8h.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting()</a></code> is used the same way as <a class="el" href="le__event_loop_8h.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId()</a>, except that it doesn't require a payload size as the payload is always known from the pointer to a reference-counted memory pool object. Only Event IDs created using <a class="el" href="le__event_loop_8h.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting()</a> can be used with <a class="el" href="le__event_loop_8h.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting()</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> EventId;</div><div class="line">le_mem_PoolRef_t MyObjectPoolRef;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MyHandler</div><div class="line">(</div><div class="line"> <span class="keywordtype">void</span>* reportPtr  <span class="comment">// Pointer to my reference-counted object.</span></div><div class="line">)</div><div class="line">{</div><div class="line">    MyObj_t* objPtr = reportPtr;</div><div class="line"></div><div class="line"> <span class="comment">// Do something with the object.</span></div><div class="line">    ...</div><div class="line"></div><div class="line"> <span class="comment">// Okay, I'm done with the object now.</span></div><div class="line"> <a class="code" href="le__mem_8h.html#a6d8e3fe430bcb81efe97b57ce30ef2de">le_mem_Release</a>(objPtr);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line">    EventId = <a class="code" href="le__event_loop_8h.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting</a>(<span class="stringliteral">"SomethingHappened"</span>);</div><div class="line"> <a class="code" href="le__event_loop_8h.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler</a>(<span class="stringliteral">"SomethingHandler"</span>, EventId, MyHandler);</div><div class="line">    MyObjectPoolRef = <a class="code" href="le__mem_8h.html#ab91efaa2978c9c1c7b2427d25b33241c">le_mem_CreatePool</a>(<span class="stringliteral">"MyObjects"</span>, <span class="keyword">sizeof</span>(MyObj_t));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ReportSomethingDetected</div><div class="line">(</div><div class="line">    ...</div><div class="line">)</div><div class="line">{</div><div class="line">    MyObj_t* objPtr = <a class="code" href="le__mem_8h.html#af7c289c73d4182835a26a9099f3db359">le_mem_ForceAlloc</a>(MyObjectPool);</div><div class="line"></div><div class="line"> <span class="comment">// Fill in the object.</span></div><div class="line">    ...</div><div class="line"></div><div class="line"> <a class="code" href="le__event_loop_8h.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting</a>(EventId, objPtr);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="c_event_miscThreadingTopics"></a>
Miscellaneous Multithreading Topics</h1>
<p>All functions in this API are thread safe.</p>
<p>Each thread can have only one Event Loop. The main thread in every Legato process will always run an Event Loop after it's run the component initialization functions. As soon as all component initialization functions have returned, the main thread will start processing its event queue.</p>
<p>When a function is called to "Add" an event handler, that handler is associated with the calling thread's Event Loop. If the calling thread doesn't run its Event Loop, the event reports will pile up in the queue, never getting serviced and never releasing their memory. This will appear in the logs as event queue growth warnings.</p>
<p>If a client starts its own thread (e.g., by calling <a class="el" href="le__thread_8h.html#a87e02a46f92e9e3e11ed28a2b265872f">le_thread_Create()</a> ), then that thread will <b>not</b> automatically run an Event Loop. To make it run an Event Loop, it must call <code><a class="el" href="le__event_loop_8h.html#ae313b457994371c658be9fe0494a01ff">le_event_RunLoop()</a></code> (which will never return).</p>
<p>If a thread running an Event Loop terminates, the Legato framework automatically deregisters any handlers and deletes the thread's Event Loop, its Event Queue, and any event reports still in that Event Queue.</p>
<h1><a class="anchor" id="c_event_integratingLegacyPosix"></a>
Integrating with Legacy POSIX Code</h1>
<p>Many legacy programs written on top of POSIX APIs will have previously built their own event loop using poll(), select(), or some other blocking functions. It may be difficult to refactor this type of event loop to use the Legato event loop instead.</p>
<p>Two functions are provided to assist integrating legacy code with the Legato Event Loop:</p><ul>
<li><code><a class="el" href="le__event_loop_8h.html#a12ce7f92f4bc6f5167d5a6ef86d7d0b1">le_event_GetFd()</a></code> - Fetches a file descriptor that can be monitored using some variant of poll() or select() (including epoll). It will appear readable when the Event Loop needs servicing.</li>
<li><code><a class="el" href="le__event_loop_8h.html#a096222e98f6a0d92a79722018a752b58">le_event_ServiceLoop()</a></code> - Services the event loop. This should be called if the file descriptor returned by <a class="el" href="le__event_loop_8h.html#a12ce7f92f4bc6f5167d5a6ef86d7d0b1">le_event_GetFd()</a> appears readable to poll() or select().</li>
</ul>
<p>In an attempt to avoid starving the caller when there are a lot of things that need servicing on the Event Loop, <code><a class="el" href="le__event_loop_8h.html#a096222e98f6a0d92a79722018a752b58">le_event_ServiceLoop()</a></code> will only perform one servicing step (i.e., call one event handler function) before returning, regardless of how much work there is to do. It's the caller's responsibility to check the return code from <a class="el" href="le__event_loop_8h.html#a096222e98f6a0d92a79722018a752b58">le_event_ServiceLoop()</a> and keep calling until it indicates that there is no more work to be done.</p>
<h1><a class="anchor" id="c_event_troubleshooting"></a>
Troubleshooting</h1>
<p>A logging keyword can be enabled to view a given thread's event handling activity. The keyword name depends on the thread and process name where the thread is located. For example, the keyword "P/T/events" controls logging for a thread named "T" running inside a process named "P".</p>
<hr />
<p class="copyright">Copyright (C) Sierra Wireless Inc. Use of this work is subject to license. </p>
</div></div>
<br clear="left" />
</div>
<div id="footer">
</div>
</div>
</body>
</html>