<div class="header">
<div class="summary">
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<h1 class="title">le_utf8.h File Reference</h1> </div>
</div><meta content="le_utf8.h File Reference" name="title"></meta><div class="contents">
<p><a href="le__utf8_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8f61f1aa523b03d02d6a89cb61449e2"><td align="right" class="memItemLeft" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#af8f61f1aa523b03d02d6a89cb61449e2">le_utf8_NumChars</a> (const char *string)</td></tr>
<tr class="separator:af8f61f1aa523b03d02d6a89cb61449e2"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a2541a26cade8cef93db889194a430008"><td align="right" class="memItemLeft" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#a2541a26cade8cef93db889194a430008">le_utf8_NumBytes</a> (const char *string)</td></tr>
<tr class="separator:a2541a26cade8cef93db889194a430008"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acf29bce77181131dc39b6ff2101b817c"><td align="right" class="memItemLeft" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#acf29bce77181131dc39b6ff2101b817c">le_utf8_NumBytesInChar</a> (const char firstByte)</td></tr>
<tr class="separator:acf29bce77181131dc39b6ff2101b817c"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:adb71a97c2df91e1c8a1af9fde34f5787"><td align="right" class="memItemLeft" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#adb71a97c2df91e1c8a1af9fde34f5787">le_utf8_IsContinuationByte</a> (const char byte)</td></tr>
<tr class="separator:adb71a97c2df91e1c8a1af9fde34f5787"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:aa5ae72c01396c106fdf3b4741ead7477"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#aa5ae72c01396c106fdf3b4741ead7477">le_utf8_Copy</a> (char *destStr, const char *srcStr, const size_t destSize, size_t *numBytesPtr)</td></tr>
<tr class="separator:aa5ae72c01396c106fdf3b4741ead7477"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:ade7dfb60b18574dc62c49b86c025579b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#ade7dfb60b18574dc62c49b86c025579b">le_utf8_Append</a> (char *destStr, const char *srcStr, const size_t destSize, size_t *destStrLenPtr)</td></tr>
<tr class="separator:ade7dfb60b18574dc62c49b86c025579b"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a6a8d87c8096a43244f6c77598bd1fb82"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#a6a8d87c8096a43244f6c77598bd1fb82">le_utf8_CopyUpToSubStr</a> (char *destStr, const char *srcStr, const char *subStr, const size_t destSize, size_t *numBytesPtr)</td></tr>
<tr class="separator:a6a8d87c8096a43244f6c77598bd1fb82"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:acffd959e1c6dcf9841217c1c0f6d09e5"><td align="right" class="memItemLeft" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#acffd959e1c6dcf9841217c1c0f6d09e5">le_utf8_IsFormatCorrect</a> (const char *string)</td></tr>
<tr class="separator:acffd959e1c6dcf9841217c1c0f6d09e5"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
<tr class="memitem:a680a92fafea1ed72dedb80b52be32a06"><td align="right" class="memItemLeft" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__utf8_8h.html#a680a92fafea1ed72dedb80b52be32a06">le_utf8_ParseInt</a> (int *valuePtr, const char *arg)</td></tr>
<tr class="separator:a680a92fafea1ed72dedb80b52be32a06"><td class="memSeparator" colspan="2">&nbsp;</td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_utf8.html">UTF-8 String Handling API</a> include file.</p>
<p class="copyright">Copyright (C) Sierra Wireless Inc. Use of this work is subject to license. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ade7dfb60b18574dc62c49b86c025579b"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_utf8_Append </td>
<td>(</td>
<td class="paramtype">char *&nbsp;</td>
<td class="paramname"><em>destStr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *&nbsp;</td>
<td class="paramname"><em>srcStr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const size_t&nbsp;</td>
<td class="paramname"><em>destSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t *&nbsp;</td>
<td class="paramname"><em>destStrLenPtr</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Appends srcStr to destStr by copying characters from srcStr to the end of destStr. The srcStr must be in UTF-8 format. The number of bytes in the resultant destStr (not including the NULL-terminator) is returned in destStrLenPtr.</p>
<p>A null-character is always added to the end of destStr after all srcStr characters have been copied.</p>
<p>This function will copy as many characters as possible from srcStr to destStr while ensuring that the resultant string (including the null-character) will fit within the destination buffer.</p>
<p>UTF-8 characters may be more than one byte long and this function will only copy whole characters not partial characters.</p>
<p>The destination string will always be Null-terminated, unless destSize is zero.</p>
<p>If destStr and srcStr overlap the behaviour of this function is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if srcStr was completely copied to the destStr. LE_OVERFLOW if srcStr was truncated when it was copied to destStr. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">destStr</td><td>Destination string. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">srcStr</td><td>UTF-8 source string. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">destSize</td><td>Size of the destination buffer in bytes. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">destStrLenPtr</td><td>Number of bytes in the resultant destination string (not including the NULL-terminator). Parameter can be set to NULL if the destination string size is not needed. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="aa5ae72c01396c106fdf3b4741ead7477"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_utf8_Copy </td>
<td>(</td>
<td class="paramtype">char *&nbsp;</td>
<td class="paramname"><em>destStr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *&nbsp;</td>
<td class="paramname"><em>srcStr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const size_t&nbsp;</td>
<td class="paramname"><em>destSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t *&nbsp;</td>
<td class="paramname"><em>numBytesPtr</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies the string in srcStr to the start of destStr and returns the number of bytes copied (not including the NULL-terminator) in numBytesPtr. Null can be passed into numBytesPtr if the number of bytes copied is not needed. The srcStr must be in UTF-8 format.</p>
<p>If the size of srcStr is less than or equal to the destination buffer size then the entire srcStr will be copied including the null-character. The rest of the destination buffer is not modified.</p>
<p>If the size of srcStr is larger than the destination buffer then the maximum number of characters (from srcStr) plus a null-character that will fit in the destination buffer is copied.</p>
<p>UTF-8 characters may be more than one byte long and this function will only copy whole characters not partial characters. Even if srcStr is larger than the destination buffer ,the copied characters may not fill the entire destination buffer because the last character copied may not align exactly with the end of the destination buffer.</p>
<p>The destination string will always be Null-terminated, unless destSize is zero.</p>
<p>If destStr and srcStr overlap the behaviour of this function is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if srcStr was completely copied to the destStr. LE_OVERFLOW if srcStr was truncated when it was copied to destStr. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">destStr</td><td>Destination where the srcStr is to be copied. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">srcStr</td><td>UTF-8 source string. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">destSize</td><td>Size of the destination buffer in bytes. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">numBytesPtr</td><td>Number of bytes copied not including the NULL-terminator. [Parameter can be set to NULL if the number of bytes copied is not needed. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6a8d87c8096a43244f6c77598bd1fb82"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_utf8_CopyUpToSubStr </td>
<td>(</td>
<td class="paramtype">char *&nbsp;</td>
<td class="paramname"><em>destStr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *&nbsp;</td>
<td class="paramname"><em>srcStr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *&nbsp;</td>
<td class="paramname"><em>subStr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const size_t&nbsp;</td>
<td class="paramname"><em>destSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t *&nbsp;</td>
<td class="paramname"><em>numBytesPtr</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies all characters from the srcStr to destStr up to the first occurrence of subStr. The subStr is not copied and instead a null-terminator is added to the destStr. The number of bytes copied (not including the null-terminator) is returned in numBytesPtr.</p>
<p>The srcStr and subStr must be in null-terminated UTF-8 strings.</p>
<p>The destination string will always be null-terminated.</p>
<p>If subStr is not found in the srcStr then this function behaves just like <a class="el" href="le__utf8_8h.html#aa5ae72c01396c106fdf3b4741ead7477">le_utf8_Copy()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if srcStr was completely copied to the destStr. LE_OVERFLOW if srcStr was truncated when it was copied to destStr. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">destStr</td><td>Destination where the srcStr is to be copied. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">srcStr</td><td>UTF-8 source string. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">subStr</td><td>Sub-string to copy up to. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">destSize</td><td>Size of the destination buffer in bytes. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">numBytesPtr</td><td>Number of bytes copied not including the NULL-terminator. Parameter can be set to NULL if the number of bytes copied is not needed. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="adb71a97c2df91e1c8a1af9fde34f5787"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">static bool le_utf8_IsContinuationByte </td>
<td>(</td>
<td class="paramtype">const char&nbsp;</td>
<td class="paramname"><em>byte</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Determines whether a given byte is a continuation (not the first byte) of a multi-byte UTF-8 character.</p>
<dl class="section return"><dt>Returns</dt><dd>True if a continuation byte. False otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">byte</td><td>The byte to check. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="acffd959e1c6dcf9841217c1c0f6d09e5"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool le_utf8_IsFormatCorrect </td>
<td>(</td>
<td class="paramtype">const char *&nbsp;</td>
<td class="paramname"><em>string</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Checks to see if the string is indeed a UTF-8 encoded, null-terminated string.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the format is correct. false if the format is incorrect. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a2541a26cade8cef93db889194a430008"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t le_utf8_NumBytes </td>
<td>(</td>
<td class="paramtype">const char *&nbsp;</td>
<td class="paramname"><em>string</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of bytes in string (not including the null-terminator).</p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in string (not including the null-terminator). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>The string. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="acf29bce77181131dc39b6ff2101b817c"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">size_t le_utf8_NumBytesInChar </td>
<td>(</td>
<td class="paramtype">const char&nbsp;</td>
<td class="paramname"><em>firstByte</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of bytes in the character that starts with a given byte.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in the character, or 0 if the byte provided is not a valid starting byte. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">firstByte</td><td>The first byte in the character. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="af8f61f1aa523b03d02d6a89cb61449e2"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">ssize_t le_utf8_NumChars </td>
<td>(</td>
<td class="paramtype">const char *&nbsp;</td>
<td class="paramname"><em>string</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of characters in string.</p>
<p>UTF-8 encoded characters may be larger than 1 byte so the number of characters is not necessarily equal to the the number of bytes in the string.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of characters in string if successful. LE_FORMAT_ERROR if the string is not UTF-8. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">string</td><td>Pointer to the string. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a class="anchor" id="a680a92fafea1ed72dedb80b52be32a06"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_utf8_ParseInt </td>
<td>(</td>
<td class="paramtype">int *&nbsp;</td>
<td class="paramname"><em>valuePtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const char *&nbsp;</td>
<td class="paramname"><em>arg</em>&nbsp;</td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Parse an integer value from a string.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK = Success.</li>
<li>LE_FORMAT_ERROR = The argument string was not an integer value.</li>
<li>LE_OUT_OF_RANGE = Value is too large to be stored in an int variable. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">valuePtr</td><td>Ptr to where the value will be stored if successful. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>The string to parse. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
</div>