<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" SYSTEM "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Component Definition .cdef  - Legato Docs</title>
<meta content="legato™ is an open source Linux-based embedded platform designed to simplify connected IoT application development" name="description" />
<meta content="#keywords" name="keywords" />
<meta content="noindex, nofollow" name="robots" />
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
<link href="/resources/images/legato.ico" rel="shortcut icon" />
<link href="/resources/images/legato.ico" rel="icon" type="image/x-icon" />
<link href="/resources/images/legato.ico" rel="shortcut icon" type="image/x-icon" />
<link href="#" rel="apple-touch-icon" />
<link href="#" rel="apple-touch-icon" sizes="72x72" />
<link href="#" rel="apple-touch-icon" sizes="114x114" />
<link href="/resources/css/style.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/resources/css/font-awesome.css" rel="stylesheet" type="text/css" />
<!--[if IE]>
        <script src="/resources/js/html5shiv.js"></script>
        <script src="/resources/js/respond.js"></script>
        <![endif]-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
<script src="/resources/js/main.js"></script>
<link href="/resources/css/jqtree.css" rel="stylesheet" type="text/css" />
<script src="/resources/js/tree.jquery.js" type="text/javascript"></script>
<script src="/resources/js/jquery.cookie.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<script>
        setupTree("/resources/tocs/Build Apps Documentation.json");
        </script>
</head>
<body>
<div class="wrapper">
<div class="fa fa-bars documentation" id="menu-trigger"></div>
<div id="top">
<header>
<nav>
<a class="navlink" href="/index.html">Introduction</a><a class="navlink" href="/docs/getstarted_main.html">Build Apps</a><a class="subnavlink" href="/docs/getstarted_main.html">Get started</a><a class="subnavlink" href="/docs/build_apps_documentation.html">Documentation</a><a class="subnavlink" href="/docs/files.html">Reference</a><a class="navlink" href="/docs/platform_constraints.html">Build Platform</a><a class="subnavlink" href="/docs/platform_constraints.html">Platform Constraints</a><a class="subnavlink" href="/docs/yocto_main.html">Yocto Info</a><a class="navlink" href="/docs/about_main.html">About</a>
</nav>
</header>
</div>
<div class="orange" id="menudocumentation">
<header>
<h1><a class="navlink" href="/" title="back to Legato homepage">Legato</a></h1>
<h2>/ Build Apps</h2>
<nav class="ui-front" id="searchresult">
<i class="fa fa-search"></i>
<input id="autocomplete" onkeyup="getdata('Build Apps')" placeholder="Search..." /> <!-- <input id="category" type="checkbox" onclick="checkbox()"> <label for="category">API Search</label> -->
</nav>
</header>
</div>
<div class="orange" id="topMenu">
<nav>
<a href="getstarted_main.html">Get Started</a><a class="link-selected" href="build_apps_documentation.html">Documentation</a><a href="files.html">Reference</a>
</nav>
</div>
<div id="left">
<div id="tree1"></div>
</div>
<div class="content">
<div class="header">
<div class="headertitle">
<h1 class="title">Component Definition .cdef </h1> </div>
</div><div class="contents">
<div class="textblock"><p><code>Component.cdef</code> files can contain these sections:</p>
<h1><a class="anchor" id="defFilesCdef_assets"></a>
Assets</h1>
<p>Used to describe collections of information (fields) that can be exchanged with cloud services like AirVantage.</p>
<p>The assets section can hold multiple assets, each asset is given a name.</p>
<p>An asset can be:</p>
<ul>
<li><code>variables</code> values that are readable by the server; writable by the client.</li>
<li><code>settings</code> values that are writable by the server; readable by the client.</li>
<li><code>commands</code> that are custom commands sent from the server and executable by the client.</li>
</ul>
<p>The variable and setting fields can have an associated data type and optionally a default value. The current data types supported are <code> bool, int, float, and string</code>.</p>
<p>In this code sample, <code>helloWorld</code> app has one setting (the message to be logged), one variable (records how many times a message has been logged). The app also exposes two commands: one to log the currently configured message and one to log the default message.</p>
<p>The <code>assets</code> definition looks like this:</p>
<pre class="fragment">assets:
{
    message =
    {
        settings:
        {
            string greeterMessage = "Hello world."   // When requested log this message.
        }

        variables:
        {
            int greetCount     // How many times has a greeting been logged?
        }

        commands:
        {
            greetNow           // Log the message recorded in greeterMessage.
            standardGreeting   // Use "Hello world," instead of what is set in greeterMessage.
        }
    }
}
</pre><p>Once you've defined your assets, it's up to the app to instantiate instances of them at run-time using the <a class="el" href="c_le_avdata.html">AirVantage Data</a> API. Also see <a class="el" href="how_to_a_v_data.html">Manage AirVantage Data</a>.</p>
<h1><a class="anchor" id="defFilesCdef_bundles"></a>
Bundles</h1>
<p>Lists additional files or directories to be copied from the build host into the app so they’re available to the app at runtime (e.g., audio files, web pages, executable scripts or programs built using some external build system).</p>
<pre class="fragment">bundles:
{
    file:
    {
        // Include the web server executable (built using some other build tool) in the app's /bin.
        [x] 3rdParty/webServer/bin/wwwServ  /bin/

        // Put the company logo into the app's /var/www/ for read-only access by the web server.
        images/abcCorpLogo.jpg  /var/www/

        // Make the appropriate welcome page for the product appear at /var/www/index.html.
        webContent/$PRODUCT_ID/welcome.html  /var/www/index.html

        // Create a file to record persistent custom audio messages into.
        [w] audio/defaultMessage.wav  /usr/share/sounds/customMessage.wav
    }

    dir:
    {
        // Recursively bundle the directory containing all the audio files into the app.
        // It will appear to the app read-only under /usr/share/sounds/.
        audio   /usr/share/sounds
    }
}
</pre><p>Three things need to be specified for each file or directory:</p><ul>
<li>access permissions</li>
<li>build system path</li>
<li>target path</li>
</ul>
<p><b>Access permissions</b> - any combination of one or more of the following letters, enclosed in square brackets:</p><ul>
<li>r = readable</li>
<li>w = writeable</li>
<li>x = executable</li>
</ul>
<p>If permissions values are not specified, then read-only ([r]) is the default.</p>
<p>Directories always have executable permission set so they can be traversed. Setting the <code>[x]</code> permission in the <code>dir:</code> subsection causes the files under the directory to be made executable.</p>
<p>Setting <code>[w]</code> in the <code>dir:</code> subsection causes all files under that directory to be writeable, but the directory itself will not be writeable.</p>
<dl class="section note"><dt>Note</dt><dd>Directories in the persistent (flash) file system are never made writeable because the on-target flash file system does not support usage quotas (yet).</dd></dl>
<p><b>Build system path</b> - file system path on the build PC where the file is located at build time.</p>
<p>The path can be relative to the directory where the <code></code>.adef file is located.</p>
<dl class="section note"><dt>Note</dt><dd>Environment variables can be used inside these paths.</dd></dl>
<p><b>Target path</b> - file system path on the target where the file will appear at runtime.</p>
<p>It's an absolute path inside the app's sandbox file system.</p>
<p>If the path ends with '/', it means the directory path where the source object (file or directory) will be copied. The destination object will have the same name as the source object.</p>
<p>If the path doesn't end in a '/', it's a full destination object path. The destination object could have a different name than the source object.</p>
<dl class="section note"><dt>Note</dt><dd>If the app is running unsandboxed, the bundled files and directories can be found in their installation location under <code>/legato/systems/current/apps/xxxx</code>, where xxxx is replaced by the app name.</dd></dl>
<p><b>Quoting Paths</b></p>
<p>File paths can be enclosed in quotation marks (either single ' or double "). This is required when the file path contains spaces or comment start sequences </p><pre class="fragment">"//" or  "/*"
</pre><p><b>File Ownership and Set-UID Bits</b></p>
<p>When the app is installed on a target: <br />
</p><ul>
<li>the owner and group are set to <code>root</code> on all files in the app.</li>
<li>the <code>setuid</code> bit is cleared on everything in the app.</li>
</ul>
<h1><a class="anchor" id="defFilesCdef_cFlags"></a>
C Flags</h1>
<p>Provides a way to specify command-line arguments to pass to the compiler when compiling C source code files.</p>
<p>Flags are separated by whitespace.</p>
<div class="fragment"><div class="line">cflags:</div><div class="line">{</div><div class="line">    -g -O0</div><div class="line">    -DDEBUG=1</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="defFilesCdef_cxxFlags"></a>
C++ Flags</h1>
<p>Provides a way to specify command-line arguments to pass to the compiler when compiling C++ source code files.</p>
<p>Flags are separated by whitespace.</p>
<div class="fragment"><div class="line">cxxflags:</div><div class="line">{</div><div class="line">    -std=c++0x</div><div class="line">    -g -O0</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="defFilesCdef_ldFlags"></a>
Linker Flags</h1>
<p>Provides a way to specify command-line arguments to pass to the compiler when linking C/C++ object (.o) files together into a component shared library (.so) file.</p>
<p>Flags are separated by whitespace.</p>
<div class="fragment"><div class="line">ldflags:</div><div class="line">{</div><div class="line">    -Lfoo/bar</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="defFilesCdef_pools"></a>
Pools</h1>
<dl class="section warning"><dt>Warning</dt><dd>This feature not yet implemented.</dd></dl>
<p>Specifies the number of memory pool blocks that each <a class="el" href="c_memory.html">memory pool</a> should contain.</p>
<div class="fragment"><div class="line">pools:</div><div class="line">{</div><div class="line">    myPool = 45</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="defFilesCdef_provides"></a>
Provides</h1>
<p>Lists things this component provides (exports) to other software either inside or outside of the app.</p>
<p>The only subsection supported today is the <code>api</code> subsection.</p>
<h2><a class="anchor" id="defFilesCdef_providesApi"></a>
API</h2>
<p>Lists IPC services provided by this component to other components.</p>
<p>Contents use the same syntax as the <code>requires:</code> <a class="el" href="def_files_cdef.html#defFilesCdef_requiresApi">API</a> section, except the options are different.</p>
<p>Here's a code sample where <code> greet.api </code> defines a function called <code>Send()</code> where the C source code for the component (in <code>greetServer.c</code>) is implement a function called <code>greet_Send()</code>.</p>
<div class="fragment"><div class="line">provides:</div><div class="line">{</div><div class="line">    api:</div><div class="line">    {</div><div class="line">        greet.api   <span class="comment">// We offer the Greet API to others so they can say “hello” to the world.</span></div><div class="line">        heat = digitalOutput.api</div><div class="line">        cool = digitalOutput.api</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">sources:</div><div class="line">{</div><div class="line">    greetServer.c</div><div class="line">    tempControl.c</div><div class="line">}</div></div><!-- fragment --><p>The component must implement the API functions being provided.</p>
<p>In C, the source code must <code>#include “interfaces.h”</code> to get the auto-generated function prototype definitions and type definitions. The function and type names defined in the <code></code>.api files are prefixed with the interface name and an underscore (similar to required APIs).</p>
<h3><a class="anchor" id="defFilesCdef_providesApiManualStart"></a>
[manual-start] Option</h3>
<p>To reduce the initialization code a component writer needs to write, the build tools automatically try to advertise the service when the executable is run. Sometimes this is not the preferred behaviour.</p>
<p>The <b><code></code>[manual-start</b>] option tells the build tools <b>not</b> to automatically advertise this API with the Service Directory when the process starts. If <code></code>[manual-start] option is used, the component can control when it wants to start offering the service to others by calling the <code>xxxx_AdvertiseService()</code> function explicitly in the component source code when it's ready.</p>
<div class="fragment"><div class="line">provides:</div><div class="line">{</div><div class="line">    api:</div><div class="line">    {</div><div class="line">        foo.api [manual-start]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="defFilesCdef_providesApiAsync"></a>
[async] Option</h3>
<p>The server of a service can also implement the functions as if they were called directly by the client (even though the client may be running inside another process). When the client calls an API function, the server's API function gets called, and when the server returns from the function, the function returns in the client process.</p>
<p>Sometimes the server needs to hold onto the client request and do other things (like handing requests from other clients in the meantime) before sending a response back. This is called asynchronous mode, and is enabled using the <code> [async] </code> keyword on the end of the <code>api</code> section entry:</p>
<div class="fragment"><div class="line">provides:</div><div class="line">{</div><div class="line">    api:</div><div class="line">    {</div><div class="line">        bar.api [async]</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>When asynchronous mode is enabled for a server-side interface, the generated code changes as follows:</p><ul>
<li><code>commandRef</code> parameter is added to the beginning of all the API functions' parameter lists.</li>
<li>return value is removed from every API function.</li>
<li><code>Respond()</code> function is generated for every API function.</li>
</ul>
<p>In async mode, the server responds to the client's call to API function <code>F()</code> by calling the associated <code>FRespond()</code> function.</p>
<p>The <code>Respond</code> functions all take the <code>commandRef</code> as their first parameter. If an API function has a return value, that return value is sent to the client through the second parameter of the <code>Respond</code> function. Any output parameters defined in the API function are also passed as parameters to the <code>Respond</code> function.</p>
<p>See <a class="el" href="api_files.html">API Files</a> for more information, or try it and have a look at the generated header files.</p>
<h1><a class="anchor" id="defFilesCdef_requires"></a>
Requires</h1>
<p>The <code>requires:</code> section specifies things the component needs from its runtime environment.</p>
<p>It can contain various subsections.</p>
<h2><a class="anchor" id="defFilesCdef_requiresApi"></a>
API</h2>
<p>Lists IPC APIs used by this component.</p>
<p>Here's a code sample of a component using the Configuration Data API (defined in le_cfg.api) to read its configuration data:</p>
<div class="fragment"><div class="line">requires:</div><div class="line">{</div><div class="line">    api:</div><div class="line">    {</div><div class="line">        le_cfg.api</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This creates a client-side IPC interface called <code>le_cfg</code> on this component, and it makes the functions and data types defined inside <code>le_cfg.api</code> available for use in the component's program code.</p>
<p>The name of the <code></code>.api file (minus the <code></code>.api extension) is the name of the interface, and in C code, the names of functions and data types defined in the <code></code>.api file are prefixed with the name of the interface with an underscore separator.</p>
<div class="fragment"><div class="line">requires:</div><div class="line">{</div><div class="line">    api:</div><div class="line">    {</div><div class="line">        print.api <span class="comment">// WriteLine() from the API will appear in my C code as "print_WriteLine()".</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>To rename the interface, an interface name followed by an equals sign ('=') can be added in front of the <code></code>.api file path.</p>
<div class="fragment"><div class="line">requires:</div><div class="line">{</div><div class="line">    api:</div><div class="line">    {</div><div class="line">        hello = greet.api <span class="comment">// Send() from the API will appear as "hello_Send()" in my code.</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Multiple instances of the same API listed in the <code>api:</code> section must have unique instance names, and appear as separate functions with different prefixes.</p>
<div class="fragment"><div class="line">requires:</div><div class="line">{</div><div class="line">    api:</div><div class="line">    {</div><div class="line">        heat = digitalOutput.api   <span class="comment">// Used to turn on and off the heater.</span></div><div class="line">        cool = digitalOutput.api   <span class="comment">// Used to turn on and off the cooling (A/C).</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>If <code> digitalOutput.api </code> defines two functions <code>On()</code> <code>and</code> Off(), the component’s source code would have four functions available to it: <code>heat_On()</code>, <code>heat_Off()</code>, <code>cool_On()</code>, and <code>cool_Off()</code>.</p>
<p>C/C++ source code must <code> #include “interfaces.h”</code> to use the auto-generated function definitions. The build tools will automatically generate a version of <code>interfaces.h</code> customized for your component that includes all declarations for all the interfaces the component uses.</p>
<p>The build tools search for the interface definition (.api) file based on the interface search path.</p>
<h3><a class="anchor" id="defFilesCdef_requiresApiOptions"></a>
Options</h3>
<p>To reduce the amount of initialization code a component needs to write, the build tools automatically generate the client-side IPC code for that API, and automatically try to connect to the server when the executable is run. There are a couple of options that can be used to suppress this behaviour.</p>
<p>The <b><code></code>[types-only</b>] option tells the build tools the client only wants to use type definitions from the API. This means the client-side IPC code will not be generated for this API, but the types defined in the API will still be available to the component (through <code>interfaces.h</code> in C/C++).</p>
<p>The <b><code></code>[manual-start</b>] option tells the build tools not to automatically connect to this API's server when the process starts. This means the component can control when it wants to connect to the server by calling the <code>xxxx_ConnectService()</code> function explicitly in the component source code.</p>
<div class="fragment"><div class="line">requires:</div><div class="line">{</div><div class="line">    api:</div><div class="line">    {</div><div class="line">        foo.api [types-only]    <span class="comment">// Only need typedefs from here.  Don't need IPC code generated.</span></div><div class="line">        bar.api [manual-start]  <span class="comment">// I'll start this when I'm ready by calling bar_ConnectService().</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="defFilesCdef_requiresFile"></a>
File</h2>
<p>Declares:</p><ul>
<li>specific files that reside on the target outside of the app, but made accessible to the app.</li>
<li>location inside the app's sandbox where the file will appear.</li>
</ul>
<p>Things listed in <code>requires</code> are expected to be found on the target at runtime. They're not copied into the app at build time; they are made accessible to the app inside of its sandbox at runtime.</p>
<p>Each entry consists of two file system paths:</p>
<ul>
<li>path to the object in the file system outside of the app, which must be an absolute path (beginning with ‘/’).</li>
<li>absolute file system path inside the app’s sandbox where the object will appear at runtime.</li>
</ul>
<p>A file path can be enclosed in quotation marks (either single ' or double "). This is required when it contains spaces or character sequences that would start comments.</p>
<p>The first path can't end in a '/'.</p>
<p>If the second path ends in a '/', then it's specifying the directory where the object appears, and the object has the same name inside the sandbox as it has outside the sandbox.</p>
<pre class="fragment">requires:
{
    file:
    {
        // I get character stream input from outside via a named pipe (read-only)
        /var/run/someNamedPipe  /var/run/

        // I need to be able to play back audio files installed in /usr/local/share/audio.
        "/usr/local/share/audio/error message.wav" /usr/share/audio/
        '/usr/local/share/audio/success message.wav' /usr/share/audio/
    }
}
</pre><dl class="section note"><dt>Note</dt><dd>Even though the file system object appears in the app's sandbox it still needs permissions settings on the file. File permissions (both DAC and MAC) and ownership (group and user) on the original file in the target system remain in effect inside the sandbox.</dd></dl>
<p>It's also possible to give the object a different names inside and outside of the sandbox by adding a name to the end of the second path.</p>
<pre class="fragment">requires:
{
    file:
    {
        // Program uses /var/run/someNamedPipe which it calls /var/run/externalPipe.
        /var/run/someNamedPipe  /var/run/externalPipe
    }
}
</pre><dl class="section warning"><dt>Warning</dt><dd>When something is accessible from inside an app sandbox, there are potential security risks (e.g., access to the object could be exploited by the app, or hacker, to access sensitive information or launch a denial-of-service attack on other apps within the target device or other devices connected to the target device).</dd></dl>
<h2><a class="anchor" id="defFilesCdef_requiresDevice"></a>
Device</h2>
<p>Declares:</p><ul>
<li>device files that reside on the target outside of the app, but made accessible to the app.</li>
<li>location inside the app's sandbox where the file will appear.</li>
<li>access permissions the app is given to the device file.</li>
</ul>
<p>Things listed in <code>requires</code> are expected to be found on the target at runtime. They're not copied into the app at build time; they are made accessible to the app inside of its sandbox at runtime.</p>
<p>Each entry consists of two file system paths and a set of optional access permissions:</p>
<ul>
<li>access permissions, readable ([r]) and/or writeable ([w]). Executable is not allowed on device files. If permission values are not specified, then read-only ([r]) is the default.</li>
<li>path to the object in the file system outside of the app, which must be an absolute path (beginning with ‘/’). This must be a path to a valid character or block device file.</li>
<li>absolute file system path inside the app’s sandbox where the object will appear at runtime.</li>
</ul>
<p>A file path can be enclosed in quotation marks (either single ' or double "). This is required when it contains spaces or character sequences that would start comments.</p>
<p>The first path can't end in a '/'.</p>
<p>If the second path ends in a '/', then it's specifying the directory where the object appears, and the object has the same name inside the sandbox as it has outside the sandbox.</p>
<pre class="fragment">requires:
{
    device:
    {
        // I get read-only access to the SPI port.
        [r]     /dev/sierra_spi   /dev/sierra_spi

        // I get read-only access to the NMEA port.
                /dev/nmea         /dev/nmea

        // I get read and write access to the I2C port.
        [rw]    /dev/sierra_i2c   /dev/
    }
}
</pre><p>Note that if a hot-plug device is unplugged and plugged back in, the app must be restarted before it can access the device.</p>
<p>It's also possible to give the object a different names inside and outside of the sandbox by adding a name to the end of the second path.</p>
<pre class="fragment">requires:
{
    device:
    {
        /dev/ttyS0  /dev/port1     // Program uses /dev/port1, but UART0 is called /dev/ttyS0.
    }
}
</pre><dl class="section warning"><dt>Warning</dt><dd>When something is accessible from inside an app sandbox, there are potential security risks (e.g., access to the object could be exploited by the app, or hacker, to access sensitive information or launch a denial-of-service attack on other apps within the target device or other devices connected to the target device).</dd>
<dd>
This section is experimental. Future releases of may not support this section.</dd></dl>
<h2><a class="anchor" id="defFilesCdef_requiresDir"></a>
Dir</h2>
<p>Specifies directories on target device to make accessible to the app.</p>
<p>The location inside the app's sandbox at which the directory will appear is also specified.</p>
<p>Things listed here are expected to be found on the target at runtime. They are not copied into the app at build time; they are made accessible to the app inside of its sandbox at runtime.</p>
<p>Each entry consists of two file system paths:</p>
<ul>
<li>The <b>first</b> path is the path to the directory <b>outside</b> of the app. This must be an absolute path (beginning with ‘/’) and can never end in a '/'.</li>
<li>The <b>second</b> path is the absolute path <b>inside</b> the app’s sandbox where the directory will appear at runtime.</li>
</ul>
<p>Paths can be enclosed in quotation marks (either single ' or double "). This is required when it contains spaces or character sequences that would start comments.</p>
<p>If the second path ends in a '/', then it's specifying the directory into which the object will appear, and the object will have the same name inside the sandbox as it has outside the sandbox.</p>
<pre class="fragment">requires:
{
    dir:
    {
        // I need access to /proc for debugging.
        /proc   /

        // For now, I want access to all executables and libraries in /bin and /lib.
        // Later I'll remove this and replace with just the files I really need in the field.
        // Also, I don't want to hide the stuff that the tools automatically bundle into my app's
        // /bin and /lib for me, so I'll make the root file system's /bin and /lib accessible as
        // my app's /usr/bin and /usr/lib.
        /bin    /usr/bin
        /lib    /usr/lib
    }
}
</pre><dl class="section note"><dt>Note</dt><dd>Although the directory appears in the app's sandbox, it doesn't mean the app can access it. The directory permissions settings must also allow it. File permissions (both DAC and MAC) and ownership (group and user) on the original files in the target system remain in effect inside the sandbox.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Any time anything is accessible from inside an app sandbox, the security risks must be considered carefully. Ask yourself if access to the object can be exploited by the app (or a hacker who has broken into the app) to access sensitive information or launch a denial-of-service attack on other apps within the target device or other devices connected to the target device?</dd></dl>
<dl class="section note"><dt>Note</dt><dd>It's not possible to put anything inside of a directory that was mapped into the app from outside of the sandbox. If you <em>require</em> <code>/bin</code> to appear at <code>/usr/bin</code>, you can't then <em>bundle</em> a file into <code>/usr/bin</code> or <em>require</em> something to appear in <code>/usr/bin</code>; that would have an effect on the contents of the /bin directory outside of the app.</dd></dl>
<h2><a class="anchor" id="defFilesCdef_requiresLib"></a>
Lib</h2>
<p>The <code>lib:</code> subsection of the <code>requires:</code> section is used to specify that a shared (dynamic) library is required by any executable that the component is part of.</p>
<p>The required library will be linked with executables that the component is a part of.</p>
<p>Specifying a shared library file's path will result in "<c>-L<c>" and "<c>-l<c>" arguments being added to the linker's command line.</p>
<p>This is useful when linking to libraries that are not part of the target's sysroot. (If the library is part of the target's sysroot, then the <code>ldflags:</code> section can be used instead.)</p>
<p>On the target device at runtime, the dynamic linker will look for the library, so it must be made available inside the app sandbox, somewhere in the dynamic linker's library search path. (The dynamic linker will typically look in the <code>/lib</code> and <code>/usr/lib</code> directories for libraries at runtime.)</p>
<p>The library file can be bundled as a part of the app using the <b><code>bundles:</code></b> section of the <code>.cdef</code> file.</p>
<div class="fragment"><div class="line">bundles:</div><div class="line">{</div><div class="line">    file:</div><div class="line">    {</div><div class="line"> <span class="comment">// Bundle the "foo" library as part of the app (in the app's /lib directory).</span></div><div class="line">        libfoo.so.3     /lib/</div><div class="line">        libfoo.so.3.1.1 /lib/</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Or, if the library is already present on the target, then the <code>files:</code> or <code>dirs:</code> subsection of the <b><code>requires:</code></b> section of either the <code>.cdef</code> or <code>.adef</code> file can be used to make the library visible from inside the app sandbox.</p>
<div class="fragment"><div class="line">requires:</div><div class="line">{</div><div class="line">    file:</div><div class="line">    {</div><div class="line"> <span class="comment">// Make the "foo" library available inside the app sandbox (in the app's /lib directory).</span></div><div class="line">        /usr/local/lib/libfoo.so.3     /lib/</div><div class="line">        /usr/local/lib/libfoo.so.3.1.1 /lib/</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>For backward compatibility, it is also possible to specify the library name "xml" without the leading "lib" or the trailing ".so". This will result in "<c>-lxml</c>" being passed to the linker when linking any executables that include this component, but will not add a '-L' option.</p>
<div class="fragment"><div class="line">requires:</div><div class="line">{</div><div class="line">    lib:</div><div class="line">    {</div><div class="line">        xml    <span class="comment">// I need access to libxml.so which is expected to already be on the target.</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This is equivalent to using the "ldflags:" section to add "-lxml" to the linker command-line arguments.</p>
<div class="fragment"><div class="line">ldflags:</div><div class="line">{</div><div class="line">    -lxml</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="defFilesCdef_requiresComponent"></a>
Component</h2>
<p>Declares this component depends on another component.</p>
<div class="fragment"><div class="line">requires:</div><div class="line">{</div><div class="line">    component:</div><div class="line">    {</div><div class="line">        foo</div><div class="line">        bar</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Any app that uses a component will also use any other components that component requires, and any components they require, etc.</p>
<p>Specifying a dependency on another component ensures that calls to component initialization functions ( <code>COMPONENT_INIT</code> in C/C++ components ) are sorted in the correct order. If component A depends on component B, then component B will be initialized first.</p>
<p>Dependency loops are not allowed: component C can't depend on another component that (either directly or indirectly) depends on component C. The build tools detect dependency loops and report any error.</p>
<h1><a class="anchor" id="defFilesCdef_sources"></a>
Sources</h1>
<p>Contains a list of source code files.</p>
<p>If C or C++ code, one source file must implement a <code>COMPONENT_INIT</code> function. The framework will automatically call that function at start-up.</p>
<div class="fragment"><div class="line">sources:</div><div class="line">{</div><div class="line">    foo.c</div><div class="line">    bar.c</div><div class="line">    init.c      <span class="comment">// This one implements the COMPONENT_INIT</span></div><div class="line">}</div></div><!-- fragment --><hr />
<p class="copyright">Copyright (C) Sierra Wireless Inc. Use of this work is subject to license. </p>
</div></div>
<br clear="left" />
</div>
<div id="footer">
</div>
</div>
</body>
</html>