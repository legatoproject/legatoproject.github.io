<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" SYSTEM "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Low-Level Messaging API  - Legato Docs</title>
<meta content="legatoâ„¢ is an open source Linux-based embedded platform designed to simplify connected IoT application development" name="description" />
<meta content="#keywords" name="keywords" />
<meta content="noindex, nofollow" name="robots" />
<meta content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
<link href="/resources/images/legato.ico" rel="shortcut icon" />
<link href="/resources/images/legato.ico" rel="icon" type="image/x-icon" />
<link href="/resources/images/legato.ico" rel="shortcut icon" type="image/x-icon" />
<link href="#" rel="apple-touch-icon" />
<link href="#" rel="apple-touch-icon" sizes="72x72" />
<link href="#" rel="apple-touch-icon" sizes="114x114" />
<link href="/resources/css/style.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/resources/css/font-awesome.css" rel="stylesheet" type="text/css" />
<!--[if IE]>
        <script src="/resources/js/html5shiv.js"></script>
        <script src="/resources/js/respond.js"></script>
        <![endif]-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"></script>
<script src="/resources/js/main.js"></script>
<link href="/resources/css/jqtree.css" rel="stylesheet" type="text/css" />
<script src="/resources/js/tree.jquery.js" type="text/javascript"></script>
<script src="/resources/js/jquery.cookie.js"></script>
<script src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>
<script>
        setupTree("/resources/tocs/Build Apps Documentation.json");
        </script>
</head>
<body>
<div class="wrapper">
<div class="fa fa-bars documentation" id="menu-trigger"></div>
<div id="top">
<header>
<nav>
<a class="navlink" href="/index.html">Introduction</a><a class="navlink" href="/docs/getstarted_main.html">Build Apps</a><a class="subnavlink" href="/docs/getstarted_main.html">Get started</a><a class="subnavlink" href="/docs/build_apps_documentation.html">Documentation</a><a class="subnavlink" href="/docs/files.html">Reference</a><a class="navlink" href="/docs/platform_constraints.html">Build Platform</a><a class="subnavlink" href="/docs/platform_constraints.html">Platform Constraints</a><a class="subnavlink" href="/docs/yocto_main.html">Yocto Info</a><a class="navlink" href="/docs/about_main.html">About</a>
</nav>
</header>
</div>
<div class="orange" id="menudocumentation">
<header>
<h1><a class="navlink" href="/" title="back to Legato homepage">Legato</a></h1>
<h2>/ Build Apps</h2>
<nav class="ui-front" id="searchresult">
<i class="fa fa-search"></i>
<input id="autocomplete" onkeyup="getdata('Build Apps')" placeholder="Search..." /> <!-- <input id="category" type="checkbox" onclick="checkbox()"> <label for="category">API Search</label> -->
</nav>
</header>
</div>
<div class="orange" id="topMenu">
<nav>
<a href="getstarted_main.html">Get Started</a><a class="link-selected" href="build_apps_documentation.html">Documentation</a><a href="files.html">Reference</a>
</nav>
</div>
<div id="left">
<div id="tree1"></div>
</div>
<div class="content">
<div class="header">
<div class="headertitle">
<h1 class="title">Low-Level Messaging API </h1> </div>
</div><div class="contents">
<div class="textblock"><p><a class="el" href="le__messaging_8h.html">API Reference</a></p>
<hr />
<p>Message-based interfaces in Legato are implemented in layers. This low-level messaging API is at the bottom layer. It's designed to support higher layers of the messaging system. But it's also intended to be easy to hand-code low-level messaging in C, when necessary.</p>
<p>This low-level messaging API supports:</p><ul>
<li>remote party identification (addressing)</li>
<li>very late (runtime) discovery and binding of parties</li>
<li>in-process and inter-process message delivery</li>
<li>location transparency</li>
<li>sessions</li>
<li>access control</li>
<li>request/reply transactions</li>
<li>message buffer memory management</li>
<li>support for single-threaded and multi-threaded programs</li>
<li>some level of protection from protocol mismatches between parties in a session.</li>
</ul>
<p>This API is integrated with the Legato Event Loop API so components can interact with each other using messaging without having to create threads or file descriptor sets that block other software from handling other events. Support for integration with legacy POSIX-based programs is also provided.</p>
<h1><a class="anchor" id="c_messagingInteractionModel"></a>
Interaction Model</h1>
<p>The Legato low-level messaging system follows a service-oriented pattern:</p><ul>
<li>Service providers advertise their service.</li>
<li>Clients open sessions with those services</li>
<li>Both sides can send and receive messages through the session.</li>
</ul>
<p>Clients and servers can both send one-way messages within a session. Clients can start a request-response transaction by sending a request to the server, and the server can send a response. Request-response transactions can be blocking or non-blocking (with a completion callback). If the server dies or terminates the session before sending the response, Legato will automatically terminate the transaction.</p>
<p>Servers are prevented from sending blocking requests to clients as a safety measure. If a server were to block waiting for one of its clients, it would open up the server to being blocked indefinitely by one of its clients, which would allow one client to cause a server to deny service to other clients. Also, if a client started a blocking request-response transaction at the same time that the server started a blocking request-response transaction in the other direction, a deadlock would occur.</p>
<h1><a class="anchor" id="c_messagingAddressing"></a>
Addressing</h1>
<p>Servers and clients have interfaces that can been connected to each other via bindings. Both client-side and server-side interfaces are identified by name, but the names don't have to match for them to be bound to each other. The binding determines which server-side interface will be connected to when a client opens a session.</p>
<p>Server-side interfaces are also known as "services".</p>
<p>When a session is opened by a client, a session reference is provided to both the client and the server. Messages are then sent within the session using the session reference. This session reference becomes invalid when the session is closed.</p>
<h1><a class="anchor" id="c_messagingProtocols"></a>
Protocols</h1>
<p>Communication between client and server is done using a message-based protocol. This protocol is defined at a higher layer than this API, so this API doesn't know the structure of the message payloads or the correct message sequences. That means this API can't check for errors in the traffic it carries. However, it does provide a basic mechanism for detecting protocol mismatches by forcing both client and server to provide the protocol identifier of the protocol to be used. The client and server must also provide the maximum message size, as an extra sanity check.</p>
<p>To make this possible, the client and server must independently call <code><a class="el" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef()</a></code>, to get a reference to a "Protocol" object that encapsulates these protocol details:</p>
<div class="fragment"><div class="line">protocolRef = <a class="code" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef</a>(MY_PROTOCOL_ID, <span class="keyword">sizeof</span>(myproto_Msg_t));</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>In this example, the protocol identifier (which is a string uniquely identifying a specific version of a specific protocol) and the message structure would be defined elsewhere, in a header file shared between the client and the server. The structure <code>myproto_Msg_t</code> contains a <code>union</code> of all of the different messages included in the protocol, thereby making <code>myproto_Msg_t</code> as big as the biggest message in the protocol.</dd></dl>
<p>When a server creates a service (by calling <a class="el" href="le__messaging_8h.html#adbbb2737069b636028128c74ae407742">le_msg_CreateService()</a>) and when a client creates a session (by calling <a class="el" href="le__messaging_8h.html#a696d7c2d4e3725d3ddb5dd2d79d2d732">le_msg_CreateSession()</a>), they are required to provide a reference to a Protocol object that they obtained from <a class="el" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef()</a>.</p>
<h1><a class="anchor" id="c_messagingClientUsage"></a>
Client Usage Model</h1>
<p><a class="el" href="c_messaging.html#c_messagingClientSending">Sending a Message</a> <br />
<a class="el" href="c_messaging.html#c_messagingClientReceiving">Receiving a Non-Response Message</a> <br />
<a class="el" href="c_messaging.html#c_messagingClientClosing">Closing Sessions</a> <br />
<a class="el" href="c_messaging.html#c_messagingClientMultithreading">Multithreading</a> <br />
<a class="el" href="c_messaging.html#c_messagingClientExample">Sample Code</a></p>
<p>Clients that want to use a service do the following:</p><ol type="1">
<li>Get a reference to the protocol they want to use by calling <code><a class="el" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef()</a></code>.</li>
<li>Create a session using <code><a class="el" href="le__messaging_8h.html#a696d7c2d4e3725d3ddb5dd2d79d2d732">le_msg_CreateSession()</a></code>, passing in the protocol reference and the client's interface name.</li>
<li>Optionally register a message receive callback using <code><a class="el" href="le__messaging_8h.html#ac726cc93219d326e1b10a7d13a0f4f65">le_msg_SetSessionRecvHandler()</a></code>.</li>
<li>Open the session using <a class="el" href="le__messaging_8h.html#a574d37960a07c4fc2bde310408619cff">le_msg_OpenSession()</a>, <a class="el" href="le__messaging_8h.html#a8c6480e3708e20e1f9da032a93c80bc0">le_msg_OpenSessionSync()</a>, or <a class="el" href="le__messaging_8h.html#a2ee1410da1dc345c86d6958b6cdda5e1">le_msg_TryOpenSessionSync()</a>.</li>
</ol>
<div class="fragment"><div class="line">protocolRef = <a class="code" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef</a>(PROTOCOL_ID, <span class="keyword">sizeof</span>(myproto_Msg_t));</div><div class="line">sessionRef = <a class="code" href="le__messaging_8h.html#a696d7c2d4e3725d3ddb5dd2d79d2d732">le_msg_CreateSession</a>(protocolRef, MY_INTERFACE_NAME);</div><div class="line"><a class="code" href="le__messaging_8h.html#ac726cc93219d326e1b10a7d13a0f4f65">le_msg_SetSessionRecvHandler</a>(sessionRef, NotifyMsgHandlerFunc, NULL);</div><div class="line"><a class="code" href="le__messaging_8h.html#a574d37960a07c4fc2bde310408619cff">le_msg_OpenSession</a>(sessionRef, SessionOpenHandlerFunc, NULL);</div></div><!-- fragment --><p>The Legato framework takes care of setting up any IPC connections, as needed (or not, if the client and server happen to be in the same process).</p>
<p>When the session opens, the Event Loop will call the "session open handler" call-back function that was passed into <a class="el" href="le__messaging_8h.html#a574d37960a07c4fc2bde310408619cff">le_msg_OpenSession()</a>.</p>
<p><a class="el" href="le__messaging_8h.html#a8c6480e3708e20e1f9da032a93c80bc0">le_msg_OpenSessionSync()</a> is a synchronous alternative to <a class="el" href="le__messaging_8h.html#a574d37960a07c4fc2bde310408619cff">le_msg_OpenSession()</a>. The difference is that <a class="el" href="le__messaging_8h.html#a8c6480e3708e20e1f9da032a93c80bc0">le_msg_OpenSessionSync()</a> will not return until the session has opened or failed to open (most likely due to permissions settings).</p>
<p><a class="el" href="le__messaging_8h.html#a2ee1410da1dc345c86d6958b6cdda5e1">le_msg_TryOpenSessionSync()</a> is like <a class="el" href="le__messaging_8h.html#a8c6480e3708e20e1f9da032a93c80bc0">le_msg_OpenSessionSync()</a> except that it will not wait for a server session to become available if it is not already available at the time of the call. That is, if the client's interface is not bound to any service, or if the service that it is bound to is not currently advertised by the server, then <a class="el" href="le__messaging_8h.html#a2ee1410da1dc345c86d6958b6cdda5e1">le_msg_TryOpenSessionSync()</a> will return an error code.</p>
<h2><a class="anchor" id="c_messagingClientSending"></a>
Sending a Message</h2>
<p>Before sending a message, the client must first allocate the message from the session's message pool using <a class="el" href="le__messaging_8h.html#a8293a69f256b98cbce5b9990ea3520f3">le_msg_CreateMsg()</a>. It can then get a pointer to the payload part of the message using <a class="el" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr()</a>. Once the message payload is populated, the client sends the message.</p>
<div class="fragment"><div class="line">msgRef = <a class="code" href="le__messaging_8h.html#a8293a69f256b98cbce5b9990ea3520f3">le_msg_CreateMsg</a>(sessionRef);</div><div class="line">msgPayloadPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line">msgPayloadPtr->... = ...; <span class="comment">// <-- Populate message payload...</span></div></div><!-- fragment --><p>If no response is required from the server, the client sends the message using <a class="el" href="le__messaging_8h.html#a073de097d281475c44a445b927fbb929">le_msg_Send()</a>. At this point, the client has handed off the message to the messaging system, and the messaging system will delete the message automatically once it has finished sending it.</p>
<div class="fragment"><div class="line"><a class="code" href="le__messaging_8h.html#a073de097d281475c44a445b927fbb929">le_msg_Send</a>(msgRef);</div></div><!-- fragment --><p>If the client expects a response from the server, the client can use <a class="el" href="le__messaging_8h.html#a5440ae06a89b60ed04e9de5601496608">le_msg_RequestResponse()</a> to send their message and specify a callback function to be called when the response arrives. This callback will be called by the event loop of the thread that created the session (i.e., the thread that called <a class="el" href="le__messaging_8h.html#a696d7c2d4e3725d3ddb5dd2d79d2d732">le_msg_CreateSession()</a>).</p>
<div class="fragment"><div class="line"><a class="code" href="le__messaging_8h.html#a5440ae06a89b60ed04e9de5601496608">le_msg_RequestResponse</a>(msgRef, ResponseHandlerFunc, NULL);</div></div><!-- fragment --><p>If the client expects an immediate response from the server, and the client wants to block until that response is received, it can use <a class="el" href="le__messaging_8h.html#aa3cf113b26b154697ccef270dafe8798">le_msg_RequestSyncResponse()</a> instead of <a class="el" href="le__messaging_8h.html#a5440ae06a89b60ed04e9de5601496608">le_msg_RequestResponse()</a>. However, keep in mind that blocking the client thread will block all event handlers that share that thread. That's why <a class="el" href="le__messaging_8h.html#aa3cf113b26b154697ccef270dafe8798">le_msg_RequestSyncResponse()</a> should only be used when the server is expected to respond immediately, or when the client thread is not shared by other event handlers.</p>
<div class="fragment"><div class="line">responseMsgRef = <a class="code" href="le__messaging_8h.html#aa3cf113b26b154697ccef270dafe8798">le_msg_RequestSyncResponse</a>(msgRef);</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>If the client and server are running in the same thread, and the client calls <a class="el" href="le__messaging_8h.html#aa3cf113b26b154697ccef270dafe8798">le_msg_RequestSyncResponse()</a>, it will return an error immediately, instead of blocking the thread. If the thread were blocked in this scenario, the server would also be blocked and would therefore be unable to receive the request and respond to it, resulting in a deadlock.</dd></dl>
<p>When the client is finished with it, the <b> client must release its reference to the response message </b> by calling <a class="el" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg()</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg</a>(responseMsgRef);</div></div><!-- fragment --><h2><a class="anchor" id="c_messagingClientReceiving"></a>
Receiving a Non-Response Message</h2>
<p>When a server sends a message to the client that is not a response to a request from the client, that non-response message will be passed to the receive handler that the client registered using <a class="el" href="le__messaging_8h.html#ac726cc93219d326e1b10a7d13a0f4f65">le_msg_SetSessionRecvHandler()</a>. In fact, this is the only kind of message that will result in that receive handler being called.</p>
<dl class="section note"><dt>Note</dt><dd>Some protocols don't include any messages that are not responses to client requests, which is why it is optional to register a receive handler on the client side.</dd></dl>
<p>The payload of a received message can be accessed using <a class="el" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr()</a>, and the client can check what session the message arrived through by calling <a class="el" href="le__messaging_8h.html#a253088f1b852575b60d7732ca7afc79b">le_msg_GetSession()</a>.</p>
<p>When the client is finished with the message, the <b> client must release its reference to the message </b> by calling <a class="el" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Function will be called whenever the server sends us a notification message.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> NotifyHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a>  msgRef,    <span class="comment">// Reference to the received message.</span></div><div class="line"> <span class="keywordtype">void</span>*                contextPtr <span class="comment">// contextPtr passed into le_msg_SetSessionRecvHandler().</span></div><div class="line">)</div><div class="line">{</div><div class="line"> <span class="comment">// Process notification message from the server.</span></div><div class="line">    myproto_Msg_t* msgPayloadPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line">    ...</div><div class="line"></div><div class="line"> <span class="comment">// Release the message, now that we are finished with it.</span></div><div class="line"> <a class="code" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg</a>(msgRef);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac05e9b3268f8fb5776adab6fe11410e5">le_msg_ProtocolRef_t</a> protocolRef;</div><div class="line"> <a class="code" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a> sessionRef;</div><div class="line"></div><div class="line">    protocolRef = <a class="code" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef</a>(PROTOCOL_ID, <span class="keyword">sizeof</span>(myproto_Msg_t));</div><div class="line">    sessionRef = <a class="code" href="le__messaging_8h.html#a696d7c2d4e3725d3ddb5dd2d79d2d732">le_msg_CreateSession</a>(protocolRef, MY_INTERFACE_NAME);</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac726cc93219d326e1b10a7d13a0f4f65">le_msg_SetSessionRecvHandler</a>(sessionRef, NotifyHandlerFunc, NULL);</div><div class="line"> <a class="code" href="le__messaging_8h.html#a574d37960a07c4fc2bde310408619cff">le_msg_OpenSession</a>(sessionRef, SessionOpenHandlerFunc, NULL);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="c_messagingClientClosing"></a>
Closing Sessions</h2>
<p>When the client is done using a service, it can close the session using <a class="el" href="le__messaging_8h.html#a1af0671de74160d99be5bfe212c39369">le_msg_CloseSession()</a>. This will leave the session object in existence, though, so that it can be opened again using <a class="el" href="le__messaging_8h.html#a574d37960a07c4fc2bde310408619cff">le_msg_OpenSession()</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="le__messaging_8h.html#a1af0671de74160d99be5bfe212c39369">le_msg_CloseSession</a>(sessionRef);</div></div><!-- fragment --><p>To delete a session object, call <a class="el" href="le__messaging_8h.html#a8d950c4b07741177d2c0927c31e3e29f">le_msg_DeleteSession()</a>. This will automatically close the session, if it is still open (but won't automatically delete any messages).</p>
<div class="fragment"><div class="line"><a class="code" href="le__messaging_8h.html#a8d950c4b07741177d2c0927c31e3e29f">le_msg_DeleteSession</a>(sessionRef);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If a client process dies while it has a session open, that session will be automatically closed and deleted by the Legato framework, so there's no need to register process clean-up handlers or anything like that for this purpose.</dd></dl>
<p>Additionally, clients can choose to call <a class="el" href="le__messaging_8h.html#a981b1b0714abba85efc19293ac6d2744">le_msg_SetSessionCloseHandler()</a> to register to be notified when a session gets closed by the server. Servers often keep state on behalf of their clients, and if the server closes the session (or if the system closes the session because the server died), the client most likely will still be operating under the assumption (now false) that the server is maintaining state on its behalf. If a client is designed to recover from the server losing its state, the client can register a close handler and handle the close.</p>
<div class="fragment"><div class="line"><a class="code" href="le__messaging_8h.html#a981b1b0714abba85efc19293ac6d2744">le_msg_SetSessionCloseHandler</a>(sessionRef, SessionCloseHandler, NULL);</div></div><!-- fragment --><p>However, most clients are not designed to recover from their session being closed by someone else, so if a close handler is not registered by a client and the session closes for some reason other than the client calling <a class="el" href="le__messaging_8h.html#a1af0671de74160d99be5bfe212c39369">le_msg_CloseSession()</a>, then the client process will be terminated.</p>
<dl class="section note"><dt>Note</dt><dd>If the client closes the session, the client-side session close handler will not be called, even if one is registered.</dd></dl>
<h2><a class="anchor" id="c_messagingClientMultithreading"></a>
Multithreading</h2>
<p>The Low-Level Messaging API is thread safe, but not async safe.</p>
<p>When a client creates a session, that session gets "attached" to the thread that created it (i.e., the thread that called <a class="el" href="le__messaging_8h.html#a696d7c2d4e3725d3ddb5dd2d79d2d732">le_msg_CreateSession()</a>). That thread will then call any callbacks registered for that session.</p>
<p>Note that this implies that if the client thread that creates the session does not run the Legato event loop then no callbacks will ever be called for that session. To work around this, move the session creation to another thread that that uses the Legato event loop.</p>
<p>Furthermore, to prevent race conditions, only the thread that is attached to a given session is allowed to call <a class="el" href="le__messaging_8h.html#aa3cf113b26b154697ccef270dafe8798">le_msg_RequestSyncResponse()</a> for that session.</p>
<h2><a class="anchor" id="c_messagingClientExample"></a>
Sample Code</h2>
<div class="fragment"><div class="line"><span class="comment">// Function will be called whenever the server sends us a notification message.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> NotifyHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a>  msgRef,    <span class="comment">// Reference to the received message.</span></div><div class="line"> <span class="keywordtype">void</span>*                contextPtr <span class="comment">// contextPtr passed into le_msg_SetSessionRecvHandler().</span></div><div class="line">)</div><div class="line">{</div><div class="line"> <span class="comment">// Process notification message from the server.</span></div><div class="line">    myproto_Msg_t* msgPayloadPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line">    ...</div><div class="line"></div><div class="line"> <span class="comment">// Release the message, now that we are finished with it.</span></div><div class="line"> <a class="code" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg</a>(msgRef);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Function will be called whenever the server sends us a response message or our</span></div><div class="line"><span class="comment">// request-response transaction fails.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> ResponseHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a>  msgRef,    <span class="comment">// Reference to response message (NULL if transaction failed).</span></div><div class="line"> <span class="keywordtype">void</span>*                contextPtr <span class="comment">// contextPtr passed into le_msg_RequestResponse().</span></div><div class="line">)</div><div class="line">{</div><div class="line"> <span class="comment">// Check if we got a response.</span></div><div class="line"> <span class="keywordflow">if</span> (msgRef == NULL)</div><div class="line">    {</div><div class="line"> <span class="comment">// Transaction failed.  No response received.</span></div><div class="line"> <span class="comment">// This might happen if the server deleted the request without sending a response,</span></div><div class="line"> <span class="comment">// or if we had registered a "Session End Handler" and the session terminated before</span></div><div class="line"> <span class="comment">// the response was sent.</span></div><div class="line"> <a class="code" href="le__log_8h.html#a3ee3d0451bd7351a6252c9487452d175">LE_ERROR</a>(<span class="stringliteral">"Transaction failed!"</span>);</div><div class="line">    }</div><div class="line"> <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line"> <span class="comment">// Process response message from the server.</span></div><div class="line">        myproto_Msg_t* msgPayloadPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line">        ...</div><div class="line"></div><div class="line"> <span class="comment">// Release the response message, now that we are finished with it.</span></div><div class="line"> <a class="code" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg</a>(msgRef);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Function will be called when the client-server session opens.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> SessionOpenHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a>  sessionRef, <span class="comment">// Reference tp the session that opened.</span></div><div class="line"> <span class="keywordtype">void</span>*                contextPtr  <span class="comment">// contextPtr passed into le_msg_OpenSession().</span></div><div class="line">)</div><div class="line">{</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a> msgRef;</div><div class="line">    myproto_Msg_t* msgPayloadPtr;</div><div class="line"></div><div class="line"> <span class="comment">// Send a request to the server.</span></div><div class="line">    msgRef = <a class="code" href="le__messaging_8h.html#a8293a69f256b98cbce5b9990ea3520f3">le_msg_CreateMsg</a>(sessionRef);</div><div class="line">    msgPayloadPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line">    msgPayloadPtr->... = ...; <span class="comment">// <-- Populate message payload...</span></div><div class="line"> <a class="code" href="le__messaging_8h.html#a5440ae06a89b60ed04e9de5601496608">le_msg_RequestResponse</a>(msgRef, ResponseHandlerFunc, NULL);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac05e9b3268f8fb5776adab6fe11410e5">le_msg_ProtocolRef_t</a> protocolRef;</div><div class="line"> <a class="code" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a> sessionRef;</div><div class="line"></div><div class="line"> <span class="comment">// Open a session.</span></div><div class="line">    protocolRef = <a class="code" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef</a>(PROTOCOL_ID, <span class="keyword">sizeof</span>(myproto_Msg_t));</div><div class="line">    sessionRef = <a class="code" href="le__messaging_8h.html#a696d7c2d4e3725d3ddb5dd2d79d2d732">le_msg_CreateSession</a>(protocolRef, MY_INTERFACE_NAME);</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac726cc93219d326e1b10a7d13a0f4f65">le_msg_SetSessionRecvHandler</a>(sessionRef, NotifyHandlerFunc, NULL);</div><div class="line"> <a class="code" href="le__messaging_8h.html#a574d37960a07c4fc2bde310408619cff">le_msg_OpenSession</a>(sessionRef, SessionOpenHandlerFunc, NULL);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="c_messagingServerUsage"></a>
Server Usage Model</h1>
<p><a class="el" href="c_messaging.html#c_messagingServerProcessingMessages">Processing Messages from Clients</a> <br />
<a class="el" href="c_messaging.html#c_messagingServerSendingNonResponse">Sending Non-Response Messages to Clients</a> <br />
<a class="el" href="c_messaging.html#c_messagingServerCleanUp">Cleaning up when Sessions Close</a> <br />
<a class="el" href="c_messaging.html#c_messagingRemovingService">Removing Service</a> <br />
<a class="el" href="c_messaging.html#c_messagingServerMultithreading">Multithreading</a> <br />
<a class="el" href="c_messaging.html#c_messagingServerExample">Sample Code</a></p>
<p>Servers that wish to offer a service do the following:</p><ol type="1">
<li>Get a reference to the protocol they want to use by calling <a class="el" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef()</a>.</li>
<li>Create a Service object using <a class="el" href="le__messaging_8h.html#adbbb2737069b636028128c74ae407742">le_msg_CreateService()</a>, passing in the protocol reference and the service name.</li>
<li>Call <a class="el" href="le__messaging_8h.html#a21c2e57ad1ffbbdfedd3987c468e3130">le_msg_SetServiceRecvHandler()</a> to register a function to handle messages received from clients.</li>
<li>Advertise the service using <a class="el" href="le__messaging_8h.html#ad3ff11d1962840f879d9c8fe7054de0c">le_msg_AdvertiseService()</a>.</li>
</ol>
<div class="fragment"><div class="line">protocolRef = <a class="code" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef</a>(PROTOCOL_ID, <span class="keyword">sizeof</span>(myproto_Msg_t));</div><div class="line">serviceRef = <a class="code" href="le__messaging_8h.html#adbbb2737069b636028128c74ae407742">le_msg_CreateService</a>(protocolRef, SERVER_INTERFACE_NAME);</div><div class="line"><a class="code" href="le__messaging_8h.html#a21c2e57ad1ffbbdfedd3987c468e3130">le_msg_SetServiceRecvHandler</a>(serviceRef, RequestMsgHandlerFunc, NULL);</div><div class="line"><a class="code" href="le__messaging_8h.html#ad3ff11d1962840f879d9c8fe7054de0c">le_msg_AdvertiseService</a>(serviceRef);</div></div><!-- fragment --><p>Once the service is advertised, clients can open it and start sending it messages. The server will receive messages via callbacks to the function it registered using <a class="el" href="le__messaging_8h.html#a21c2e57ad1ffbbdfedd3987c468e3130">le_msg_SetServiceRecvHandler()</a>.</p>
<p>Servers also have the option of being notified when sessions are opened by clients. They get this notification by registering a handler function using <a class="el" href="le__messaging_8h.html#a829d6450d487166e0b2994b4bf44ee5d">le_msg_AddServiceOpenHandler()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Function will be called whenever a client opens a session with our service.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> SessionOpenHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a>  sessionRef, </div><div class="line"> <span class="keywordtype">void</span>*                contextPtr  </div><div class="line">)</div><div class="line">{</div><div class="line"> <span class="comment">// Handle new session opening...</span></div><div class="line">    ...</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac05e9b3268f8fb5776adab6fe11410e5">le_msg_ProtocolRef_t</a> protocolRef;</div><div class="line"> <a class="code" href="le__messaging_8h.html#ad9f0b13cde1d8c1eab5318dbcf0d9e28">le_msg_ServiceRef_t</a> serviceRef;</div><div class="line"></div><div class="line"> <span class="comment">// Create my service and advertise it.</span></div><div class="line">    protocolRef = <a class="code" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef</a>(PROTOCOL_ID, <span class="keyword">sizeof</span>(myproto_Msg_t));</div><div class="line">    serviceRef = <a class="code" href="le__messaging_8h.html#adbbb2737069b636028128c74ae407742">le_msg_CreateService</a>(protocolRef, SERVER_INTERFACE_NAME);</div><div class="line"> <a class="code" href="le__messaging_8h.html#a829d6450d487166e0b2994b4bf44ee5d">le_msg_AddServiceOpenHandler</a>(serviceRef, SessionOpenHandlerFunc, NULL);</div><div class="line"> <a class="code" href="le__messaging_8h.html#ad3ff11d1962840f879d9c8fe7054de0c">le_msg_AdvertiseService</a>(serviceRef);</div><div class="line">}</div></div><!-- fragment --><p>Both the "Open Handler" and the "Receive Handler" will be called by the Legato event loop in the thread that registered those handlers (which must also be the same thread that created the service).</p>
<h2><a class="anchor" id="c_messagingServerProcessingMessages"></a>
Processing Messages from Clients</h2>
<p>The payload of any received message can be accessed using <a class="el" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr()</a>.</p>
<p>If a received message does not require a response (i.e., if the client sent it using <a class="el" href="le__messaging_8h.html#a073de097d281475c44a445b927fbb929">le_msg_Send()</a>), then when the server is finished with the message, the server must release the message by calling <a class="el" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg()</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RequestMsgHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a> msgRef  <span class="comment">// Reference to the received message.</span></div><div class="line">)</div><div class="line">{</div><div class="line">    myproto_Msg_t* msgPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line"> <a class="code" href="le__log_8h.html#a4ebab29f40ee8eaaa87205fe3f9aaa13">LE_INFO</a>(<span class="stringliteral">"Received request '%s'"</span>, msgPtr->request.string);</div><div class="line"></div><div class="line"> <span class="comment">// No response required and I'm done with this message, so release it.</span></div><div class="line"> <a class="code" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg</a>(msgRef);</div><div class="line">}</div></div><!-- fragment --><p>If a received message requires a response (i.e., if the client sent it using <a class="el" href="le__messaging_8h.html#a5440ae06a89b60ed04e9de5601496608">le_msg_RequestResponse()</a> or <a class="el" href="le__messaging_8h.html#aa3cf113b26b154697ccef270dafe8798">le_msg_RequestSyncResponse()</a>), the server must eventually respond to that message by calling <a class="el" href="le__messaging_8h.html#ac4545833ad2da9bb4cc5d18125f7d9f2">le_msg_Respond()</a> on that message. <a class="el" href="le__messaging_8h.html#ac4545833ad2da9bb4cc5d18125f7d9f2">le_msg_Respond()</a> sends the message back to the client that sent the request. The response payload is stored inside the same payload buffer that contained the request payload.</p>
<p>To do this, the request payload pointer can be cast to a pointer to the response payload structure, and then the response payload can be written into it.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RequestMsgHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a> msgRef  <span class="comment">// Reference to the received message.</span></div><div class="line">)</div><div class="line">{</div><div class="line">    myproto_RequestMsg_t* requestPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line">    myproto_ResponseMsg_t* responsePtr;</div><div class="line"></div><div class="line"> <a class="code" href="le__log_8h.html#a4ebab29f40ee8eaaa87205fe3f9aaa13">LE_INFO</a>(<span class="stringliteral">"Received request '%s'"</span>, requestPtr->string);</div><div class="line"></div><div class="line">    responsePtr = (myproto_ResponseMsg_t*)requestPtr;</div><div class="line">    responsePtr->value = Value;</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac4545833ad2da9bb4cc5d18125f7d9f2">le_msg_Respond</a>(msgRef);</div><div class="line">}</div></div><!-- fragment --><p>Alternatively, the request payload structure and the response payload structure could be placed into a union together.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></div><div class="line">{</div><div class="line">    myproto_Request_t request;</div><div class="line">    myproto_Response_t response;</div><div class="line">}</div><div class="line">myproto_Msg_t;</div><div class="line"></div><div class="line"> ...</div><div class="line"></div><div class="line">void RequestMsgHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a> msgRef  <span class="comment">// Reference to the received message.</span></div><div class="line">)</div><div class="line">{</div><div class="line">    myproto_Msg_t* msgPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line"> <a class="code" href="le__log_8h.html#a4ebab29f40ee8eaaa87205fe3f9aaa13">LE_INFO</a>(<span class="stringliteral">"Received request '%s'"</span>, msgPtr->request.string);</div><div class="line">    msgPtr->response.value = Value;</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac4545833ad2da9bb4cc5d18125f7d9f2">le_msg_Respond</a>(msgRef);</div><div class="line">}</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Of course, once you've started writing the response payload into the buffer, the request payload is no longer available, so if you still need it, copy it somewhere else first.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The server doesn't have to send the response back to the client right away. It could hold onto the request for an indefinite amount of time, for whatever reason.</dd></dl>
<p>Whenever any message is received from a client, the message is associated with the session through which the client sent it. A reference to the session can be retrieved from the message, if needed, by calling <a class="el" href="le__messaging_8h.html#a253088f1b852575b60d7732ca7afc79b">le_msg_GetSession()</a>. This can be handy for tagging things in the server's internal data structures that need to be cleaned up when the client closes the session (see <a class="el" href="c_messaging.html#c_messagingServerCleanUp">Cleaning up when Sessions Close</a> for more on this).</p>
<p>The function <a class="el" href="le__messaging_8h.html#a8b0824781c030b9ed6f8be48e4d20419">le_msg_NeedsResponse()</a> can be used to check if a received message requires a response or not.</p>
<h2><a class="anchor" id="c_messagingServerSendingNonResponse"></a>
Sending Non-Response Messages to Clients</h2>
<p>If a server wants to send a non-response message to a client, it first needs a reference to the session that client opened. It could have got the session reference from a previous message received from the client (by calling <a class="el" href="le__messaging_8h.html#a253088f1b852575b60d7732ca7afc79b">le_msg_GetSession()</a> on that message). Or, it could have got the session reference from a Session Open Handler callback (see <a class="el" href="le__messaging_8h.html#a829d6450d487166e0b2994b4bf44ee5d">le_msg_AddServiceOpenHandler()</a>). Either way, once it has the session reference, it can call <a class="el" href="le__messaging_8h.html#a8293a69f256b98cbce5b9990ea3520f3">le_msg_CreateMsg()</a> to create a message from that session's server-side message pool. The message can then be populated and sent in the same way that a client would send a message to the server using <a class="el" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr()</a> and <a class="el" href="le__messaging_8h.html#a073de097d281475c44a445b927fbb929">le_msg_Send()</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Function will be called whenever a client opens a session with our service.</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> SessionOpenHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a>  sessionRef, </div><div class="line"> <span class="keywordtype">void</span>*                contextPtr  </div><div class="line">)</div><div class="line">{</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a> msgRef;</div><div class="line">    myproto_Msg_t* msgPayloadPtr;</div><div class="line"></div><div class="line"> <span class="comment">// Send a "Welcome" message to the client.</span></div><div class="line">    msgRef = <a class="code" href="le__messaging_8h.html#a8293a69f256b98cbce5b9990ea3520f3">le_msg_CreateMsg</a>(sessionRef);</div><div class="line">    msgPayloadPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line">    msgPayloadPtr->... = ...; <span class="comment">// <-- Populate message payload...</span></div><div class="line"> <a class="code" href="le__messaging_8h.html#a073de097d281475c44a445b927fbb929">le_msg_Send</a>(msgRef);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac05e9b3268f8fb5776adab6fe11410e5">le_msg_ProtocolRef_t</a> protocolRef;</div><div class="line"> <a class="code" href="le__messaging_8h.html#ad9f0b13cde1d8c1eab5318dbcf0d9e28">le_msg_ServiceRef_t</a> serviceRef;</div><div class="line"></div><div class="line"> <span class="comment">// Create my service and advertise it.</span></div><div class="line">    protocolRef = <a class="code" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef</a>(PROTOCOL_ID, <span class="keyword">sizeof</span>(myproto_Msg_t));</div><div class="line">    serviceRef = <a class="code" href="le__messaging_8h.html#adbbb2737069b636028128c74ae407742">le_msg_CreateService</a>(protocolRef, SERVER_INTERFACE_NAME);</div><div class="line"> <a class="code" href="le__messaging_8h.html#a829d6450d487166e0b2994b4bf44ee5d">le_msg_AddServiceOpenHandler</a>(serviceRef, SessionOpenHandlerFunc, NULL);</div><div class="line"> <a class="code" href="le__messaging_8h.html#ad3ff11d1962840f879d9c8fe7054de0c">le_msg_AdvertiseService</a>(serviceRef);</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="c_messagingServerCleanUp"></a>
Cleaning up when Sessions Close</h2>
<p>If a server keeps state on behalf of its clients, it can call <a class="el" href="le__messaging_8h.html#a426dfbae396599d80e52902165368907">le_msg_AddServiceCloseHandler()</a> to ask to be notified when clients close sessions with a given service. This allows the server to clean up any state associated with a given session when the client closes that session (or when the system closes the session because the client died). The close handler is passed a session reference, so the server can check its internal data structures and clean up anything that it has previously tagged with that same session reference.</p>
<dl class="section note"><dt>Note</dt><dd>Servers don't delete sessions. On the server side, sessions are automatically deleted when they close.</dd></dl>
<h2><a class="anchor" id="c_messagingRemovingService"></a>
Removing Service</h2>
<p>If a server wants to stop offering a service, it can hide the service by calling <a class="el" href="le__messaging_8h.html#a38cc9dec16a758c5262d8bb5c7a2e57f">le_msg_HideService()</a>. This will not terminate any sessions that are already open, but it will prevent clients from opening new sessions until it is advertised again.</p>
<dl class="section warning"><dt>Warning</dt><dd>Watch out for race conditions here. It's possible that a client is in the process of opening a session when you decide to hide your service. In this case, a new session may open after you hid the service. Be prepared to handle that gracefully.</dd></dl>
<p>The server also has the option to delete the service. This hides the service and closes all open sessions.</p>
<p>If a server process dies, the Legato framework will automatically delete all of its services.</p>
<h2><a class="anchor" id="c_messagingServerMultithreading"></a>
Multithreading</h2>
<p>The Low-Level Messaging API is thread safe, but not async safe.</p>
<p>When a server creates a service, that service gets attached to the thread that created it (i.e., the thread that called <a class="el" href="le__messaging_8h.html#adbbb2737069b636028128c74ae407742">le_msg_CreateService()</a>). That thread will call any handler functions registered for that service.</p>
<p>Note that this implies that if the thread that creates the service does not run the Legato event loop, then no callbacks will ever be called for that service. To work around this, you could move the service to another thread that that runs the Legato event loop.</p>
<h2><a class="anchor" id="c_messagingServerExample"></a>
Sample Code</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> RequestMsgHandlerFunc</div><div class="line">(</div><div class="line"> <a class="code" href="le__messaging_8h.html#a1e5c37fdd50a4d6d24cad82cb166f770">le_msg_MessageRef_t</a> msgRef,     <span class="comment">// Reference to the received message.</span></div><div class="line"> <span class="keywordtype">void</span>*               contextPtr  </div><div class="line">)</div><div class="line">{</div><div class="line"> <span class="comment">// Check the message type to decide what to do.</span></div><div class="line">    myproto_Msg_t* msgPtr = <a class="code" href="le__messaging_8h.html#a32d1c7ffd913db8546f6f1bd5cce58c4">le_msg_GetPayloadPtr</a>(msgRef);</div><div class="line"> <span class="keywordflow">switch</span> (msgPtr->type)</div><div class="line">    {</div><div class="line"> <span class="keywordflow">case</span> MYPROTO_MSG_TYPE_SET_VALUE:</div><div class="line"> <span class="comment">// Message does not require a response.</span></div><div class="line">             Value = msgPtr->...;</div><div class="line"> <a class="code" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg</a>(msgRef);</div><div class="line"> <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line"> <span class="keywordflow">case</span> MYPROTO_MSG_TYPE_GET_VALUE:</div><div class="line"> <span class="comment">// Message is a request that requires a response.</span></div><div class="line"> <span class="comment">// Notice that we just reuse the request message buffer for the response.</span></div><div class="line">             msgPtr->... = Value;</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac4545833ad2da9bb4cc5d18125f7d9f2">le_msg_Respond</a>(msgRef);</div><div class="line"> <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line"> <span class="keywordflow">default</span>:</div><div class="line"> <span class="comment">// Unexpected message type!</span></div><div class="line"> <a class="code" href="le__log_8h.html#a3ee3d0451bd7351a6252c9487452d175">LE_ERROR</a>(<span class="stringliteral">"Received unexpected message type %d from session %s."</span>,</div><div class="line">                      msgPtr->type,</div><div class="line"> <a class="code" href="le__messaging_8h.html#a32e952eda728d1a1b4236d879bfc05f9">le_msg_GetInterfaceName</a>(<a class="code" href="le__messaging_8h.html#a708715b598d1ecbe3f62f52f5955a61c">le_msg_GetSessionInterface</a>(<a class="code" href="le__messaging_8h.html#a253088f1b852575b60d7732ca7afc79b">le_msg_GetSession</a>(msgRef))));</div><div class="line"> <a class="code" href="le__messaging_8h.html#afc508c24d0b6933e8fbc4e0410d50271">le_msg_ReleaseMsg</a>(msgRef);</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__event_loop_8h.html#abdb9187a56836a93d19cc793cbd4b7ec">COMPONENT_INIT</a></div><div class="line">{</div><div class="line"> <a class="code" href="le__messaging_8h.html#ac05e9b3268f8fb5776adab6fe11410e5">le_msg_ProtocolRef_t</a> protocolRef;</div><div class="line"> <a class="code" href="le__messaging_8h.html#ad9f0b13cde1d8c1eab5318dbcf0d9e28">le_msg_ServiceRef_t</a> serviceRef;</div><div class="line"></div><div class="line"> <span class="comment">// Create my service and advertise it.</span></div><div class="line">    protocolRef = <a class="code" href="le__messaging_8h.html#adcd1ff1a6906433aaa6d7038125c4473">le_msg_GetProtocolRef</a>(PROTOCOL_ID, <span class="keyword">sizeof</span>(myproto_Msg_t));</div><div class="line">    serviceRef = <a class="code" href="le__messaging_8h.html#adbbb2737069b636028128c74ae407742">le_msg_CreateService</a>(protocolRef, SERVER_INTERFACE_NAME);</div><div class="line"> <a class="code" href="le__messaging_8h.html#a21c2e57ad1ffbbdfedd3987c468e3130">le_msg_SetServiceRecvHandler</a>(serviceRef, RequestMsgHandlerFunc, NULL);</div><div class="line"> <a class="code" href="le__messaging_8h.html#ad3ff11d1962840f879d9c8fe7054de0c">le_msg_AdvertiseService</a>(serviceRef);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="c_messagingStartUp"></a>
Start Up Sequencing</h1>
<p>Worthy of special mention is the fact that the low-level messaging system can be used to solve the age-old problem of coordinating the start-up sequence of processes that interact with each other. Far too often, the start-up sequence of multiple interacting processes is addressed using hacks like polling or sleeping for arbitrary lengths of time. These solutions can waste a lot of CPU cycles and battery power, slow down start-up, and (in the case of arbitrary sleeps) introduce race conditions that can cause failures in the field.</p>
<p>In Legato, a messaging client can attempt to open a session before the server process has even started. The client will be notified asynchronously (via callback) when the server advertises its service.</p>
<p>In this way, clients are guaranteed to wait for the servers they use, without the inefficiency of polling, and without having to add code elsewhere to coordinate the start-up sequence. Furthermore, if there is work that needs to be done by the client at start-up before it opens a session with the server, the client is allowed to do that work in parallel with the start-up of the server, so the CPU can be more fully utilized to shorten the overall duration of the start-up sequence.</p>
<h1><a class="anchor" id="c_messagingMemoryManagement"></a>
Memory Management</h1>
<p>Message buffer memory is allocated and controlled behind the scenes, inside the Messaging API. This allows the Messaging API to</p><ul>
<li>take some steps to remove programmer pitfalls,</li>
<li>provide some built-in remote troubleshooting features</li>
<li>encapsulate the IPC implementation, allowing for future optimization and porting.</li>
</ul>
<p>Each message object is allocated from a session. The sessions' message pool sizes can be tuned through component and application configuration files and device configuration settings.</p>
<p>Generally speaking, message payload sizes are determined by the protocol that is being used. Application protocols and the packing of messages into message buffers are the domain of higher-layers of the software stack. But, at this low layer, servers and clients just declare the name and version of the protocol, and the size of the largest message in the protocol. From this, they obtain a protocol reference that they provide to sessions when they create them.</p>
<h1><a class="anchor" id="c_messagingSecurity"></a>
Security</h1>
<p>Security is provided in the form of authentication and access control.</p>
<p>Clients cannot open sessions with servers until their client-side interface is "bound" to a server-side interface (service). The binding thereby provides configuration of both routing and access control.</p>
<p>Neither the client-side nor the server-side IPC sockets are named. Therefore, no process other than the Service Directory has access to these sockets. The Service Directory passes client connections to the appropriate server based on the binding configuration of the client's interface.</p>
<p>The binding configuration is kept in the "system" configuration tree, so clients that do not have write access to the "system" configuration tree have no control over their own binding configuration. By default, sandboxed apps do not have any access (read or write) to the "system" configuration tree.</p>
<h1><a class="anchor" id="c_messagingClientUserIdChecking"></a>
Client User ID Checking</h1>
<p>In rare cases, a server may wish to check the user ID of the remote client. Generally, this is not necessary because the IPC system enforces user-based access control restrictions automatically before allowing an IPC connection to be established. However, sometimes it may be useful when the service wishes to change the way it behaves, based on what user is connected to it.</p>
<p><a class="el" href="le__messaging_8h.html#a8c04f9cad0a768b4922a9987df84b65f">le_msg_GetClientUserId()</a> can be used to fetch the user ID of the client at the far end of a given IPC session.</p>
<div class="fragment"><div class="line">uid_t clientUserId;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="le__messaging_8h.html#a8c04f9cad0a768b4922a9987df84b65f">le_msg_GetClientUserId</a>(sessionRef, &clientUserId) != LE_OK)</div><div class="line">{</div><div class="line"> <span class="comment">// The session must have closed.</span></div><div class="line">    ...</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line"> <a class="code" href="le__log_8h.html#a4ebab29f40ee8eaaa87205fe3f9aaa13">LE_INFO</a>(<span class="stringliteral">"My client has user ID %ud."</span>, clientUserId);</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="c_messagingSendingFileDescriptors"></a>
Sending File Descriptors</h1>
<p>It is possible to send an open file descriptor through an IPC session by adding an fd to a message before sending it. On the sender's side, <a class="el" href="le__messaging_8h.html#a43459773ce8a9febf0f2e66681e40e91">le_msg_SetFd()</a> is used to set the file descriptor to be sent. On the receiver's side, <a class="el" href="le__messaging_8h.html#a1eff9dd7f93de58f5678ad3d6e0b734d">le_msg_GetFd()</a> is used to get the fd from the message.</p>
<p>The IPC API will close the original fd in the sender's address space once it has been sent, so if the sender still needs the fd open on its side, it should duplicate the fd (e.g., using dup() ) before sending it.</p>
<p>On the receiving side, if the fd is not extracted from the message, it will be closed when the message is released. The fd can only be extracted from the message once. Subsequent calls to <a class="el" href="le__messaging_8h.html#a1eff9dd7f93de58f5678ad3d6e0b734d">le_msg_GetFd()</a> will return -1.</p>
<p>As a denial-of-service prevention measure, receiving of file descriptors is disabled by default on servers. To enable receiving of file descriptors, the server must call le_msg_EnableFdReception() on their service.</p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT SEND DIRECTORY FILE DESCRIPTORS. That can be exploited to break out of chroot() jails.</dd></dl>
<h1><a class="anchor" id="c_messagingFutureEnhancements"></a>
Future Enhancements</h1>
<p>As an optimization to reduce the number of copies in cases where the sender of a message already has the message payload of their message assembled somewhere (perhaps as static data or in another message buffer received earlier from somewhere), a pointer to the payload could be passed to the message, instead of having to copy the payload into the message.</p>
<div class="fragment"><div class="line">msgRef = <a class="code" href="le__messaging_8h.html#a8293a69f256b98cbce5b9990ea3520f3">le_msg_CreateMsg</a>(sessionRef);</div><div class="line">le_msg_SetPayloadBuff(msgRef, &msgPayload, <span class="keyword">sizeof</span>(msgPayload));</div><div class="line">msgRef = <a class="code" href="le__messaging_8h.html#a5440ae06a89b60ed04e9de5601496608">le_msg_RequestResponse</a>(msgRef, ResponseHandlerFunc, contextPtr);</div></div><!-- fragment --><p>Perhaps an "iovec" version could be added to do scatter-gather too?</p>
<h1><a class="anchor" id="c_messagingDesignNotes"></a>
Design Notes</h1>
<p>We explored the option of having asynchronous messages automatically released when their handler function returns, unless the handler calls an "AddRef" function before returning. That would reduce the amount of code required in the common case. However, we chose to require that the client release the message explicitly in all cases, because the consequences of using an invalid reference can be catastrophic and much more difficult to debug than forgetting to release a message (which will generate pool growth warning messages in the log).</p>
<h1><a class="anchor" id="c_messagingTroubleshooting"></a>
Troubleshooting</h1>
<p>If you are running as the super-user (root), you can trace messaging traffic using <b>TBD</b>. You can also inspect message queues and view lists of outstanding message objects within processes using the Process Inspector tool.</p>
<p>If you are leaking messages by forgetting to release them when you are finished with them, you will see warning messages in the log indicating that your message pool is growing. You should be able to tell by the name of the expanding pool which messaging service it is related to.</p>
<hr />
<p class="copyright">Copyright (C) Sierra Wireless Inc. Use of this work is subject to license. </p>
</div></div>
<br clear="left" />
</div>
<div id="footer">
</div>
</div>
</body>
</html>